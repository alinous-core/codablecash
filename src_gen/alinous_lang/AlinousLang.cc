/* AlinousLang.cc */
#include "AlinousLang.h"
#include "TokenMgrError.h"
namespace alinouslang {
  unsigned int jj_la1_0[] = {
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x600000,0x200000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x400000,0x400000,0xd340200,0x0,0x0,0x0,0x0,0xd140200,0x80000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa000000,0x30800000,0x30800000,0x8000000,0x5000000,0x5000000,0x5000000,0x0,0x0,0x140200,0x0,0x0,0xd140200,0x140200,0x0,0x0,0xd140200,0x0,0x140200,0x0,0x140000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x180200,0x0,0x0,0x180200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x400000,0xa000000,0xa000000,0x30800000,0x30800000,0x980200,0x0,0x0,0x980200,0x0,0x180200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x140000,0x0,0x140000,0x0,0xd140200,0x140000,0x140000,};
  unsigned int jj_la1_1[] = {
0x1000000,0x6000000,0x800000,0x80,0x6000000,0x0,0x100,0x0,0x20000,0x0,0x0,0x100,0x80,0x0,0x0,0x0,0x4,0x800,0x0,0x0,0x100,0xe0000000,0x10,0xe0000000,0x100,0xf0000000,0x0,0x0,0xf0080814,0x10000000,0x0,0x0,0xe0000000,0x80814,0x0,0x0,0x2,0x0,0x1,0x6000,0x6000,0x78000,0x78000,0x200000,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000,0x814,0x80,0x100,0x80814,0x814,0x4,0x100,0x80814,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x100,0x0,0x100,0x100,0x100,0x0,0x0,0x0,0x0,0x40000000,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x100,0x4,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x78000,0x78000,0x4000,0x4000,0x0,0x0,0x0,0x0,0x4,0x40,0x100,0x44,0x100,0x0,0x0,0x80,0x80,0x0,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x80,0x0,0x810,0x100,0x0,0x100,0x80814,0x0,0x810,};
  unsigned int jj_la1_2[] = {
0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x800,0x0,0x800,0x10000,0x0,0x0,0x380000,0x800000,0x9000000,0x0,0x0,0x0,0x380000,0x0,0x8000001f,0x0,0x8000001f,0x0,0xd040a31f,0x0,0x0,0xd944a31f,0x5040a300,0x40,0x1000,0x8000001f,0x9040000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9040000,0x0,0x0,0x9040000,0x9040000,0x0,0x0,0x9040000,0x9000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9380000,0x0,0x9380000,0x0,0x0,0x0,0x0,0x0,0x9380000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x9380000,0x0,0x0,0x0,0x0,0x0,0x0,0x9040000,0x0,0x0,};
  unsigned int jj_la1_3[] = {
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff7c0000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf1,0x0,0x0,0xff7c00fd,0x1,0x0,0x0,0x0,0xff7c000c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff7c000c,0x0,0x0,0xff7c000c,0xff7c000c,0x0,0x0,0xff7c000c,0xff7c0000,0xc,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0xc,0x0,0xf0,0x100,0x400,0x2000000,0x10000000,0x0,0x0,0x8000000,0x80000000,0x0,0x400,0x0,0x0,0x0,0x400,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0xff7c0000,0x0,0xff7c000c,0x0,0x0,0xc,0x0,0x0,0xff7c0000,0x0,0x0,0x458000,0x458000,0x0,0x80000,0x0,0x80000,0x0,0x0,0xff7c0000,0x0,0x0,0x0,0x0,0x0,0x0,0xff7c000c,0x0,0x0,};
  unsigned int jj_la1_4[] = {
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdec3fb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f800,0x0,0x0,0xffdffbfb,0x0,0x0,0x0,0x0,0xffdec3fb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdec3fb,0x0,0x0,0xffdec3fb,0xffdec3fb,0x0,0x0,0xffdec3fb,0xffdec3fb,0x0,0x0,0x0,0x1c000,0x388000,0x800000,0x1400000,0x400000,0x5400000,0x0,0x400000,0x4000000,0x0,0x0,0x0,0x0,0x1000000,0x4,0x4000000,0x0,0x40000,0x0,0x0,0x0,0x3800,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x200,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffdec3fb,0x0,0xffdec3ff,0x0,0x0,0x0,0x0,0x0,0xffdec3fb,0x0,0x0,0x0,0x0,0x2,0x0,0x2,0x0,0x2,0x2,0xffdec3fb,0x0,0x8,0x0,0x0,0x0,0x0,0xffdec3fb,0x0,0x0,};
  unsigned int jj_la1_5[] = {
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000003,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x1000000,0x0,0x1000000,0x0,0x0,0x1010003,0x0,0x0,0x0,0x1000000,0x1010003,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1010003,0x0,0x0,0x1010003,0x1010003,0x0,0x0,0x1010003,0x1000003,0x10000,0x0,0x0,0x0,0x0,0x1000000,0x1000001,0x0,0x1000001,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x10000,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x1000003,0x0,0x1010003,0x0,0x0,0x0,0x0,0x0,0x1000003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000003,0x0,0x0,0x1000000,0x0,0x1000000,0x0,0x1010003,0x1000000,0x1000000,};
  unsigned int jj_la1_6[] = {
0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,};

  /** Constructor with user supplied TokenManager. */




CompilationUnit
               * AlinousLang::compilationUnit() {CompilationUnit* unit = new CompilationUnit();
        PackageDeclare* pkg = nullptr;
        ImportsDeclare* imports = nullptr;
        ClassDeclare* clazz = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PACKAGE:{
      if (!hasError) {
      pkg = packageDeclare();
      }
      if (!hasError) {
unit->setPackage(pkg);
      }
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    imports = importsDeclare();
    }
    if (!hasError) {
unit->setImports(imports);
    }
    if (!hasError) {
    while (!hasError) {
      if (!hasError) {
      clazz = classDeclare();
      }
      if (!hasError) {
unit->setPosition(clazz);
                        unit->addClassDeclare(clazz);
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CLASS:
      case CLASS_INTERFACE:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        goto end_label_1;
      }
    }
    end_label_1: ;
    }
    if (!hasError) {
    jj_consume_token(0);
    }
return unit;
assert(false);
}


ImportsDeclare              * AlinousLang::importsDeclare() {ImportsDeclare* importsDeclare = new ImportsDeclare();
        ImportDeclare* dec = nullptr;
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IMPORT:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        goto end_label_2;
      }
      if (!hasError) {
      dec = importDeclare();
      }
      if (!hasError) {
importsDeclare->addImport(dec);
                        importsDeclare->setPosition(dec);
      }
    }
    end_label_2: ;
    }
    if (!hasError) {

    }
__ONERROR(importsDeclare);
                return importsDeclare;
assert(false);
}


ImportDeclare             * AlinousLang::importDeclare() {ImportDeclare* dec = new ImportDeclare();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(IMPORT);
    }
    if (!hasError) {
dec->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
dec->setPosition(t);
                dec->appendStr(t->image.c_str());
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        goto end_label_3;
      }
      if (!hasError) {
      t = jj_consume_token(DOT);
      }
      if (!hasError) {
dec->setPosition(t);
                        dec->appendStr(t->image.c_str());
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
dec->setPosition(t);
                        dec->appendStr(t->image.c_str());
      }
    }
    end_label_3: ;
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
dec->setPosition(t);
    }
__ONERROR(dec);
                return dec;
assert(false);
}


PackageDeclare              * AlinousLang::packageDeclare() {PackageDeclare* pkg = nullptr;
        PackageNameDeclare* name = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(PACKAGE);
    }
    if (!hasError) {
pkg=new PackageDeclare();
                pkg->setPosition(t);
    }
    if (!hasError) {
    name = packageNameDeclare();
    }
    if (!hasError) {
pkg->setName(name);
                pkg->setPosition(name);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
pkg->setPosition(t);
    }
__ONERROR(pkg);
                return pkg;
assert(false);
}


PackageNameDeclare                  * AlinousLang::packageNameDeclare() {PackageNameDeclare* names = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
names = new PackageNameDeclare();
                names->addSegment(_STR(t));
                names->setPosition(t);
    }
    if (!hasError) {
    while (!hasError) {
      if (jj_2_1(2)) {
        ;
      } else {
        goto end_label_4;
      }
      if (!hasError) {
      jj_consume_token(DOT);
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
names->addSegment(_STR(t));
                        names->setPosition(t);
      }
    }
    end_label_4: ;
    }
    if (!hasError) {

    }
__ONERROR(names);
                return names;
assert(false);
}


ClassDeclare            * AlinousLang::classDeclare() {ClassDeclare* clazz = nullptr;
        GenericsClassDeclare* gclazz = nullptr;
        GenericsParameter* param = nullptr;
        Token* cls = nullptr;
        Token* name = nullptr;
        ClassName* genericsExtendsName = nullptr;
        ClassDeclareBlock* block = nullptr;
        Token* t = nullptr;
        ClassExtends* clsextends = nullptr;
        ClassImplements*  clsimplements = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CLASS:{
      if (!hasError) {
      cls = jj_consume_token(CLASS);
      }
      if (!hasError) {
clazz = new ClassDeclare();
      }
      break;
      }
    case CLASS_INTERFACE:{
      if (!hasError) {
      cls = jj_consume_token(CLASS_INTERFACE);
      }
      if (!hasError) {
clazz = new ClassDeclare();
                        clazz->setInterface(true);
      }
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {
    name = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
clazz->setName(_STR(name));
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LT:{
      if (!hasError) {
      t = jj_consume_token(LT);
      }
      if (!hasError) {
gclazz = new GenericsClassDeclare();
                        gclazz->setName(new UnicodeString(clazz->getName())); // copy class name

                        delete clazz;
                        clazz = gclazz;
      }
      if (!hasError) {
      name = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
param = new GenericsParameter();
                        param->setPosition(name);
                        param->setGenericsName(_STR(name));

                        gclazz->addGenericsParameter(param);
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXTENDS:{
        if (!hasError) {
        t = jj_consume_token(EXTENDS);
        }
        if (!hasError) {
param->setPosition(t);
        }
        if (!hasError) {
        genericsExtendsName = className();
        }
        if (!hasError) {
param->setGenericsExtendsName(genericsExtendsName);
                                param->setPosition(genericsExtendsName);
        }
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          goto end_label_5;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
param = new GenericsParameter();
                                param->setPosition(t);
        }
        if (!hasError) {
        name = jj_consume_token(IDENTIFIER);
        }
        if (!hasError) {
param->setPosition(name);
                                param->setGenericsName(_STR(name));

                                gclazz->addGenericsParameter(param);
        }
        if (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EXTENDS:{
          if (!hasError) {
          t = jj_consume_token(EXTENDS);
          }
          if (!hasError) {
param->setPosition(t);
          }
          if (!hasError) {
          genericsExtendsName = className();
          }
          if (!hasError) {
param->setGenericsExtendsName(genericsExtendsName);
                                        param->setPosition(genericsExtendsName);
          }
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        }
      }
      end_label_5: ;
      }
      if (!hasError) {
      t = jj_consume_token(GT);
      }
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EXTENDS:{
      if (!hasError) {
      clsextends = classExtends();
      }
      if (!hasError) {
clazz->setExtends(clsextends);
      }
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IMPLEMENTS:{
      if (!hasError) {
      clsimplements = classImplements();
      }
      if (!hasError) {
clazz->setImplements(clsimplements);
      }
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    block = classDeclareBlock();
    }
    if (!hasError) {
clazz->setPositions(cls, block);
            clazz->setBlock(block);
    }
__ONERROR(clazz);
                return clazz;
assert(false);
}


ClassExtends            * AlinousLang::classExtends() {ClassExtends* extends = new ClassExtends();
        ClassName* name = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(EXTENDS);
    }
    if (!hasError) {
extends->setPosition(t);
    }
    if (!hasError) {
    name = className();
    }
    if (!hasError) {
extends->setPosition(name);
                extends->setClassName(name);
    }
__ONERROR(extends);
                return extends;
assert(false);
}


ClassImplements               * AlinousLang::classImplements() {ClassImplements*  implements = new ClassImplements();
        ClassName* name = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(IMPLEMENTS);
    }
    if (!hasError) {
implements->setPosition(t);
    }
    if (!hasError) {
    name = className();
    }
    if (!hasError) {
implements->setPosition(name);
                implements->addClassName(name);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        goto end_label_6;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
implements->setPosition(t);
      }
      if (!hasError) {
      name = className();
      }
      if (!hasError) {
implements->setPosition(name);
                        implements->addClassName(name);
      }
    }
    end_label_6: ;
    }
    if (!hasError) {

    }
__ONERROR(implements);
                return implements;
assert(false);
}


ClassName         * AlinousLang::className() {ClassName* name = new ClassName();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
name->setPosition(t);
                name->addStr(t->image.c_str());
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[12] = jj_gen;
        goto end_label_7;
      }
      if (!hasError) {
      t = jj_consume_token(DOT);
      }
      if (!hasError) {
name->setPosition(t);
                        name->addStr(t->image.c_str());
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
name->setPosition(t);
                        name->addStr(t->image.c_str());
      }
    }
    end_label_7: ;
    }
    if (!hasError) {

    }
__ONERROR(name);
                return name;
assert(false);
}


ClassDeclareBlock                 * AlinousLang::classDeclareBlock() {ClassDeclareBlock* block = nullptr;
        Token* begin, *end;

        MethodDeclare* method = nullptr;
        MemberVariableDeclare* member = nullptr;

        AccessControlDeclare* ctrl = nullptr;
        bool _static=false;
        AbstractType* type = nullptr;
        Token* t=nullptr;
    if (!hasError) {
    begin = jj_consume_token(L_BRACE);
    }
    if (!hasError) {
block = new ClassDeclareBlock();
                block->setPosition(begin);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        goto end_label_8;
      }
      if (!hasError) {
      ctrl = accessControlDeclare();
      }
      if (!hasError) {

      }
      if (!hasError) {
      if (jj_2_3(2)) {
        if (!hasError) {
        if (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case STATIC:{
          if (!hasError) {
          t = jj_consume_token(STATIC);
          }
          if (!hasError) {
_static=true;
          }
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          ;
        }
        }
        if (!hasError) {
        if (jj_2_2(2)) {
          if (!hasError) {
          type = typeDeclare();
          }
          if (!hasError) {

          }
        } else {
          ;
        }
        }
        if (!hasError) {
        t = identifierName();
        }
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SUPER:
        case THIS:
        case INNER:
        case OUTER:
        case FULL:
        case JOIN:
        case CROSS:
        case VALUES:
        case GROUP:
        case BY:
        case HAVING:
        case ORDER:
        case ASC:
        case DESC:
        case LIMIT:
        case OFFSET:
        case ON:
        case AS:
        case DISTINCT:
        case SHARE:
        case NOWAIT:
        case OF:
        case IN:
        case BETWEEN:
        case CREATE:
        case DROP:
        case TABLE:
        case SQL_DEFAULT:
        case ADD:
        case RENAME:
        case COLUMN:
        case TO:
        case PRIMARY:
        case KEY:
        case UNIQUE:
        case CHECK:
        case RETURNS:
        case SETOF:
        case LANGUAGE:
        case REPLACE:
        case INDEX:
        case USING:
        case IDENTIFIER:{
          if (!hasError) {
          if (!hasError) {
          t = identifierName();
          }
          }
          break;
          }
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case L_PARENTHESIS:{
        if (!hasError) {
        method = methodDeclare(ctrl, _static, type, t);
        }
        if (!hasError) {
block->addMethod(method);
        }
        break;
        }
      case SEMI_COLON:
      case EQUALS:{
        if (!hasError) {
        member = memberVariableDeclare(ctrl, _static, type, t);
        }
        if (!hasError) {
block->addVariable(member);
        }
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
_static = false;
                    type = nullptr;
      }
    }
    end_label_8: ;
    }
    if (!hasError) {
    end = jj_consume_token(R_BRACE);
    }
    if (!hasError) {
block->setPosition(end);
    }
__ONERROR(block);
                return block;
assert(false);
}


MethodDeclare             * AlinousLang::methodDeclare(AccessControlDeclare* ctrl, bool _static, AbstractType* type, Token* identifier) {MethodDeclare* method = new MethodDeclare();

    method->setPosition(ctrl);

        method->setAccessControl(ctrl);
        method->setStatic(_static);
        method->setType(type);
        method->setName(_STR(identifier));

        Token* t = nullptr;
        ArgumentsListDeclare* args = nullptr;
        StatementBlock* block = nullptr;
    if (!hasError) {
    args = argumentsListDeclare();
    }
    if (!hasError) {
method->setArguments(args);
                method->setPosition(args);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_BRACE:{
      if (!hasError) {
      block = statementBlock();
      }
      if (!hasError) {
method->setBlock(block);
                        method->setPosition(block);
      }
      break;
      }
    case SEMI_COLON:{
      if (!hasError) {
      t = jj_consume_token(SEMI_COLON);
      }
      if (!hasError) {
method->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
__ONERROR(method);
                return method;
assert(false);
}


MemberVariableDeclare                     * AlinousLang::memberVariableDeclare(AccessControlDeclare* ctrl, bool _static, AbstractType* type, Token* identifier) {MemberVariableDeclare* variable = new MemberVariableDeclare();
        Token* t = nullptr;

        variable->setPosition(ctrl);

        variable->setAccessControl(ctrl);
        variable->setStatic(_static);
        variable->setType(type);
        variable->setName(_STR(identifier));

        AbstractExpression* exp = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:{
      if (!hasError) {
      t = jj_consume_token(EQUALS);
      }
      if (!hasError) {
variable->setPosition(t);
      }
      if (!hasError) {
      exp = expression();
      }
      if (!hasError) {
variable->setPosition(exp);
                        variable->setExp(exp);
      }
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
variable->setPosition(t);
    }
__ONERROR(variable);
                return variable;
assert(false);
}


AccessControlDeclare                    * AlinousLang::accessControlDeclare() {Token* t = nullptr;
        AccessControlDeclare* ctrl = new AccessControlDeclare();
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PUBLIC:{
      if (!hasError) {
      t = jj_consume_token(PUBLIC);
      }
      if (!hasError) {
ctrl->setCtrl(AccessControlDeclare::PUBLIC);
                        ctrl->setPositions(_P(t, t));
      }
      break;
      }
    case PROTECTED:{
      if (!hasError) {
      t = jj_consume_token(PROTECTED);
      }
      if (!hasError) {
ctrl->setCtrl(AccessControlDeclare::PROTECTED);
                        ctrl->setPositions(_P(t, t));
      }
      break;
      }
    case PRIVATE:{
      if (!hasError) {
      t = jj_consume_token(PRIVATE);
      }
      if (!hasError) {
ctrl->setCtrl(AccessControlDeclare::PRIVATE);
                        ctrl->setPositions(_P(t, t));
      }
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
__ONERROR(ctrl);
                return ctrl;
assert(false);
}


ArgumentsListDeclare                    * AlinousLang::argumentsListDeclare() {ArgumentsListDeclare* arguments = new ArgumentsListDeclare();
        Token* t = nullptr;
        ArgumentDeclare* arg = nullptr;
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
arguments->setPosition(t);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case SHORT:
    case INT:
    case LONG:
    case STRING:
    case VAR:
    case VOID:
    case IDENTIFIER:{
      if (!hasError) {
      arg = argumentDeclare();
      }
      if (!hasError) {
arguments->addArgument(arg);
                    arguments->setPosition(arg);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[20] = jj_gen;
          goto end_label_9;
        }
        if (!hasError) {
        jj_consume_token(COMMA);
        }
        if (!hasError) {
        arg = argumentDeclare();
        }
        if (!hasError) {
arguments->addArgument(arg);
                        arguments->setPosition(arg);
        }
      }
      end_label_9: ;
      }
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
arguments->setPosition(t);
    }
__ONERROR(arguments);
                return arguments;
assert(false);
}


ArgumentDeclare               * AlinousLang::argumentDeclare() {ArgumentDeclare* arg = new ArgumentDeclare();
        AbstractType* type = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    type = typeDeclare();
    }
    if (!hasError) {
arg->setType(type);
                arg->setPosition(type);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
arg->setName(_STR(t));
                arg->setPosition(t);
    }
__ONERROR(arg);
                return arg;
assert(false);
}


AbstractType            * AlinousLang::typeDeclare() {AbstractType* dec = nullptr;
        Token* t1 = nullptr;
        Token* t2 = nullptr;
    if (!hasError) {
    dec = typeBody();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case L_BRACKET:{
        ;
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        goto end_label_10;
      }
      if (!hasError) {
      t1 = jj_consume_token(L_BRACKET);
      }
      if (!hasError) {
      t2 = jj_consume_token(R_BRACKET);
      }
      if (!hasError) {
dec->addDimension();
      }
    }
    end_label_10: ;
    }
    if (!hasError) {

    }
__ONERROR(dec);
                return dec;
assert(false);
}


AbstractType            * AlinousLang::typeBody() {AbstractType* dec = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BOOLEAN:{
      if (!hasError) {
      dec = boolType();
      }
      break;
      }
    case BYTE:{
      if (!hasError) {
      dec = byteType();
      }
      break;
      }
    case CHAR:{
      if (!hasError) {
      dec = charType();
      }
      break;
      }
    case SHORT:{
      if (!hasError) {
      dec = shortType();
      }
      break;
      }
    case INT:{
      if (!hasError) {
      dec = intType();
      }
      break;
      }
    case LONG:{
      if (!hasError) {
      dec = longType();
      }
      break;
      }
    case STRING:{
      if (!hasError) {
      dec = stringType();
      }
      break;
      }
    case VOID:{
      if (!hasError) {
      dec = voidType();
      }
      break;
      }
    case VAR:{
      if (!hasError) {
      dec = domType();
      }
      break;
      }
    case IDENTIFIER:{
      if (!hasError) {
      dec = objectType();
      }
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
__ONERROR(dec);
                return dec;
assert(false);
}


ObjectType          * AlinousLang::objectType() {ObjectType* dec = new ObjectType();
        PackageNameDeclare* packageName = nullptr;
        Token* t=nullptr;
        GenericsObjectType* geneticsObject = nullptr;
        AbstractType* genericsType = nullptr;
    if (!hasError) {
    while (!hasError) {
      if (jj_2_4(2)) {
        ;
      } else {
        goto end_label_11;
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
if(packageName == nullptr){
                                packageName = new PackageNameDeclare();
                                dec->setPackageName(packageName);
                        }

                        dec->setPosition(t);
                        packageName->setPosition(t);
                        packageName->addSegment(_STR(t));
      }
      if (!hasError) {
      t = jj_consume_token(DOT);
      }
      if (!hasError) {
dec->setPosition(t);
      }
    }
    end_label_11: ;
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
dec->setName(_STR(t));
                dec->setPosition(t);
    }
    if (!hasError) {
    if (jj_2_5(2)) {
      if (!hasError) {
      t = jj_consume_token(LT);
      }
      if (!hasError) {
geneticsObject = new GenericsObjectType(dec);
                        delete dec;
                        dec = geneticsObject;
      }
      if (!hasError) {
      genericsType = typeDeclare();
      }
      if (!hasError) {
geneticsObject->addGenericsType(genericsType);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[24] = jj_gen;
          goto end_label_12;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
geneticsObject->setPosition(t);
        }
        if (!hasError) {
        genericsType = typeDeclare();
        }
        if (!hasError) {
geneticsObject->addGenericsType(genericsType);
        }
      }
      end_label_12: ;
      }
      if (!hasError) {
      t = jj_consume_token(GT);
      }
      if (!hasError) {
geneticsObject->setPosition(t);
      }
    } else {
      ;
    }
    }
__ONERROR(dec);
                return dec;
assert(false);
}


BoolType        * AlinousLang::boolType() {BoolType* dec = new BoolType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(BOOLEAN);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


ByteType        * AlinousLang::byteType() {ByteType* dec = new ByteType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(BYTE);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


CharType        * AlinousLang::charType() {CharType* dec = new CharType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(CHAR);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


ShortType         * AlinousLang::shortType() {ShortType* dec = new ShortType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(SHORT);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


IntType       * AlinousLang::intType() {IntType* dec = new IntType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(INT);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


LongType        * AlinousLang::longType() {LongType* dec = new LongType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(LONG);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


StringType          * AlinousLang::stringType() {StringType* dec = new StringType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(STRING);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


VoidType        * AlinousLang::voidType() {VoidType* dec = new VoidType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(VOID);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


DomType       * AlinousLang::domType() {DomType* dec = new DomType();
        Token* t=nullptr;
    if (!hasError) {
    t = jj_consume_token(VAR);
    }
    if (!hasError) {
dec->setPositions(_P(t, t));
    }
__ONERROR(dec);
                return dec;
assert(false);
}


AbstractStatement
                 * AlinousLang::statement() {AbstractStatement* stmt = nullptr;
    if (!hasError) {
    if (jj_2_6(3)) {
      if (!hasError) {
      stmt = statementBlock();
      }
    } else if (jj_2_7(4)) {
      if (!hasError) {
      stmt = substitutionStatement();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case STRING:
      case VAR:
      case VOID:
      case IDENTIFIER:{
        if (!hasError) {
        stmt = variableDeclareStatement();
        }
        break;
        }
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case IF:
      case RETURN:
      case THROW:
      case TRY:
      case WHILE:{
        if (!hasError) {
        //stmt=expressionStatement() |
                        stmt = ctrlStatement();
        }
        break;
        }
      case SEMI_COLON:{
        if (!hasError) {
        stmt = blankStatement();
        }
        break;
        }
      case CREATE:
      case DROP:
      case ALTER:{
        if (!hasError) {
        stmt = ddlStatement();
        }
        break;
        }
      case SELECT:
      case INSERT:
      case UPDATE:
      case DELETE:
      case BEGIN:
      case COMMIT:
      case ROLLBACK:{
        if (!hasError) {
        stmt = sqlDmlStatement();
        }
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    }
    }
    if (!hasError) {

    }
return stmt;
assert(false);
}


VariableDeclareStatement                        * AlinousLang::variableDeclareStatement() {VariableDeclareStatement* stmt = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    stmt = __variableDeclareStatement();
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


VariableDeclareStatement                        * AlinousLang::__variableDeclareStatement() {VariableDeclareStatement* stmt = new VariableDeclareStatement();
        AbstractType* type = nullptr;
        VariableIdentifier* valId = nullptr;
        AbstractExpression* exp = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    type = typeDeclare();
    }
    if (!hasError) {
stmt->setType(type);
                stmt->setPosition(type);
    }
    if (!hasError) {
    valId = variableIdentifier();
    }
    if (!hasError) {
stmt->setVariableId(valId);
                stmt->setPosition(valId);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:{
      if (!hasError) {
      t = jj_consume_token(EQUALS);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      exp = expression();
      }
      if (!hasError) {
stmt->setInitExpression(exp);
                        stmt->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


AbstractStatement                 * AlinousLang::substitutionStatement() {AbstractStatement* stmt = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    stmt = __substitutionStatement();
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


AbstractStatement                 * AlinousLang::__substitutionStatement() {AbstractStatement* stmt = nullptr;

        AbstractExpression* first = nullptr;
        AbstractExpression* exp = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    first = expression();
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:{
      if (!hasError) {
      t = jj_consume_token(EQUALS);
      }
      if (!hasError) {
      exp = expression();
      }
      if (!hasError) {
SubstitutionStatement* sstmt = new SubstitutionStatement();
                        stmt = sstmt;
                        sstmt->setVariableId(first);
                        sstmt->setPosition(first);

                        sstmt->setExpression(exp);
                        sstmt->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    }
    if (!hasError) {
if(stmt == nullptr){
                        ExpressionStatement* exstmt = new ExpressionStatement();
                        stmt = exstmt;
                        exstmt->setExpression(first);
                        exstmt->setPosition(first);
                }
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


BlankStatement              * AlinousLang::blankStatement() {BlankStatement* stmt = new BlankStatement();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
                stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


StatementBlock              * AlinousLang::statementBlock() {StatementBlock* block = new StatementBlock();
        AbstractStatement* stmt = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(L_BRACE);
    }
    if (!hasError) {
block->setPosition(t);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case STRING_LITERAL:
      case SQL_STRING_LITERAL:
      case SEMI_COLON:
      case PLUSPLUS:
      case MINUSMINUS:
      case MINUS:
      case L_PARENTHESIS:
      case L_BRACKET:
      case L_BRACE:
      case NOT:
      case BREAK:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case STRING:
      case VAR:
      case CONTINUE:
      case DO:
      case FOR:
      case IF:
      case NEW:
      case RETURN:
      case SUPER:
      case THIS:
      case THROW:
      case TRY:
      case VOID:
      case WHILE:
      case TRUE:
      case FALSE:
      case SELECT:
      case INSERT:
      case UPDATE:
      case DELETE:
      case INNER:
      case OUTER:
      case FULL:
      case JOIN:
      case CROSS:
      case VALUES:
      case GROUP:
      case BY:
      case HAVING:
      case ORDER:
      case ASC:
      case DESC:
      case LIMIT:
      case OFFSET:
      case ON:
      case AS:
      case DISTINCT:
      case SHARE:
      case NOWAIT:
      case OF:
      case IN:
      case BETWEEN:
      case BEGIN:
      case COMMIT:
      case ROLLBACK:
      case CREATE:
      case DROP:
      case ALTER:
      case TABLE:
      case SQL_DEFAULT:
      case ADD:
      case RENAME:
      case COLUMN:
      case TO:
      case PRIMARY:
      case KEY:
      case UNIQUE:
      case CHECK:
      case RETURNS:
      case SETOF:
      case LANGUAGE:
      case REPLACE:
      case INDEX:
      case USING:
      case _NULL:
      case IDENTIFIER:
      case 193:{
        ;
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        goto end_label_13;
      }
      if (!hasError) {
      stmt = statement();
      }
      if (!hasError) {
block->addStatement(stmt);
                        block->setPosition(stmt);
      }
    }
    end_label_13: ;
    }
    if (!hasError) {
    t = jj_consume_token(R_BRACE);
    }
    if (!hasError) {
block->setPosition(t);
    }
__ONERROR(block);
                return block;
assert(false);
}


AbstractStatement
                 * AlinousLang::ctrlStatement() {AbstractStatement* stmt = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case THROW:{
      if (!hasError) {
      stmt = throwStatement();
      }
      break;
      }
    case TRY:{
      if (!hasError) {
      stmt = tryStatement();
      }
      break;
      }
    case IF:{
      if (!hasError) {
      stmt = ifStatement();
      }
      break;
      }
    case BREAK:{
      if (!hasError) {
      stmt = breakStatement();
      }
      break;
      }
    case CONTINUE:{
      if (!hasError) {
      stmt = continueStatement();
      }
      break;
      }
    case RETURN:{
      if (!hasError) {
      stmt = returnStatement();
      }
      break;
      }
    case WHILE:{
      if (!hasError) {
      stmt = whileStatement();
      }
      break;
      }
    case DO:{
      if (!hasError) {
      stmt = doWhileStatement();
      }
      break;
      }
    case FOR:{
      if (!hasError) {
      stmt = forStatement();
      }
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
return stmt;
assert(false);
}


TryStatement            * AlinousLang::tryStatement() {TryStatement* stmt = new TryStatement();
        StatementBlock* block = nullptr;
        Token* t = nullptr;

        CatchStatement* catchStmt = nullptr;
        FinallyStatement* finallyStmt = nullptr;
    if (!hasError) {
    t = jj_consume_token(TRY);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    block = statementBlock();
    }
    if (!hasError) {
stmt->setBlock(block);
                stmt->setPosition(block);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CATCH:{
        ;
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        goto end_label_14;
      }
      if (!hasError) {
      catchStmt = catchStatement();
      }
      if (!hasError) {
stmt->addCatchStatement(catchStmt);
                        stmt->setPosition(catchStmt);
      }
    }
    end_label_14: ;
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FINALLY:{
      if (!hasError) {
      finallyStmt = finallyStatement();
      }
      if (!hasError) {
stmt->setFinallyStatement(finallyStmt);
                        stmt->setPosition(finallyStmt);
      }
      break;
      }
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


FinallyStatement                * AlinousLang::finallyStatement() {FinallyStatement* stmt = new FinallyStatement();
        StatementBlock* block = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(FINALLY);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    block = statementBlock();
    }
    if (!hasError) {
stmt->setBlock(block);
                stmt->setPosition(block);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


CatchStatement              * AlinousLang::catchStatement() {CatchStatement* stmt = new CatchStatement();
        StatementBlock* block = nullptr;
        Token* t = nullptr;

        VariableDeclareStatement* variableDeclare = nullptr;
    if (!hasError) {
    t = jj_consume_token(CATCH);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    variableDeclare = __variableDeclareStatement();
    }
    if (!hasError) {
stmt->setVariableDeclare(variableDeclare);
                stmt->setPosition(variableDeclare);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    block = statementBlock();
    }
    if (!hasError) {
stmt->setBlock(block);
                stmt->setPosition(block);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


ThrowStatement              * AlinousLang::throwStatement() {ThrowStatement* stmt = new ThrowStatement();
        AbstractExpression* exp = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(THROW);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    exp = expression();
    }
    if (!hasError) {
stmt->setExpression(exp);
                stmt->setPosition(exp);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


ForStatement            * AlinousLang::forStatement() {ForStatement* stmt = new ForStatement();
        AbstractExpression* exp = nullptr;
        AbstractStatement* st = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(FOR);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    st = forInnerStatement();
    }
    if (!hasError) {
stmt->setInit(st);
                stmt->setPosition(st);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    exp = expression();
    }
    if (!hasError) {
stmt->setCondition(exp);
                stmt->setPosition(exp);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    st = forInnerStatement();
    }
    if (!hasError) {
stmt->setPostLoop(st);
                stmt->setPosition(st);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    st = statement();
    }
    if (!hasError) {
stmt->setStatement(st);
                stmt->setPosition(st);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


AbstractStatement                 * AlinousLang::forInnerStatement() {AbstractStatement* stmt = nullptr;
    if (!hasError) {
    if (jj_2_8(2)) {
      if (!hasError) {
      stmt = __substitutionStatement();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case SHORT:
      case INT:
      case LONG:
      case STRING:
      case VAR:
      case VOID:
      case IDENTIFIER:{
        if (!hasError) {
        stmt = __variableDeclareStatement();
        }
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    }
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


DoWhileStatement                * AlinousLang::doWhileStatement() {DoWhileStatement* stmt = new DoWhileStatement();
        AbstractExpression* exp = nullptr;
        AbstractStatement* st = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(DO);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    st = statement();
    }
    if (!hasError) {
stmt->setStatement(st);
                stmt->setPosition(st);
    }
    if (!hasError) {
    t = jj_consume_token(WHILE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    exp = expression();
    }
    if (!hasError) {
stmt->setExpression(exp);
                stmt->setPosition(exp);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


WhileStatement              * AlinousLang::whileStatement() {WhileStatement* stmt = new WhileStatement();
        AbstractExpression* exp = nullptr;
        AbstractStatement* st = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(WHILE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    exp = expression();
    }
    if (!hasError) {
stmt->setExpression(exp);
                stmt->setPosition(exp);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    st = statement();
    }
    if (!hasError) {
stmt->setStatement(st);
                stmt->setPosition(st);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


ReturnStatement               * AlinousLang::returnStatement() {ReturnStatement* stmt = new ReturnStatement();
        AbstractExpression* exp = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(RETURN);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:
    case PLUSPLUS:
    case MINUSMINUS:
    case MINUS:
    case L_PARENTHESIS:
    case L_BRACKET:
    case L_BRACE:
    case NOT:
    case NEW:
    case SUPER:
    case THIS:
    case TRUE:
    case FALSE:
    case INNER:
    case OUTER:
    case FULL:
    case JOIN:
    case CROSS:
    case VALUES:
    case GROUP:
    case BY:
    case HAVING:
    case ORDER:
    case ASC:
    case DESC:
    case LIMIT:
    case OFFSET:
    case ON:
    case AS:
    case DISTINCT:
    case SHARE:
    case NOWAIT:
    case OF:
    case IN:
    case BETWEEN:
    case CREATE:
    case DROP:
    case TABLE:
    case SQL_DEFAULT:
    case ADD:
    case RENAME:
    case COLUMN:
    case TO:
    case PRIMARY:
    case KEY:
    case UNIQUE:
    case CHECK:
    case RETURNS:
    case SETOF:
    case LANGUAGE:
    case REPLACE:
    case INDEX:
    case USING:
    case _NULL:
    case IDENTIFIER:
    case 193:{
      if (!hasError) {
      exp = expression();
      }
      if (!hasError) {
stmt->setExpression(exp);
                        stmt->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


ContinueStatement                 * AlinousLang::continueStatement() {ContinueStatement* stmt = new ContinueStatement();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(CONTINUE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


BreakStatement              * AlinousLang::breakStatement() {BreakStatement* stmt = new BreakStatement();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(BREAK);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


IfStatement           * AlinousLang::ifStatement() {IfStatement* ifstmt = new IfStatement();
        AbstractExpression* exp;
        AbstractStatement* stmt;
        Token* t = nullptr;

        IfStatement* elseif = nullptr;
    if (!hasError) {
    t = jj_consume_token(IF);
    }
    if (!hasError) {
ifstmt->setPosition(t);
    }
    if (!hasError) {
    jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
    exp = expression();
    }
    if (!hasError) {
ifstmt->setExpression(exp);
                ifstmt->setPosition(exp);
    }
    if (!hasError) {
    jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
    stmt = statement();
    }
    if (!hasError) {
ifstmt->setStatement(stmt);
                ifstmt->setPosition(stmt);
    }
    if (!hasError) {
    while (!hasError) {
      if (jj_2_9(2)) {
        ;
      } else {
        goto end_label_15;
      }
      if (!hasError) {
      elseif = elseifStatement();
      }
      if (!hasError) {
ifstmt->addElseIf(elseif);
                        ifstmt->setPosition(elseif);
      }
    }
    end_label_15: ;
    }
    if (!hasError) {
    if (jj_2_10(2)) {
      if (!hasError) {
      t = jj_consume_token(ELSE);
      }
      if (!hasError) {
ifstmt->setPosition(t);
      }
      if (!hasError) {
      stmt = statement();
      }
      if (!hasError) {
ifstmt->setElseStatement(stmt);
                        ifstmt->setPosition(stmt);
      }
    } else {
      ;
    }
    }
__ONERROR(ifstmt);
                return ifstmt;
assert(false);
}


IfStatement           * AlinousLang::elseifStatement() {IfStatement* ifstmt = new IfStatement();
        AbstractExpression* exp;
        AbstractStatement* stmt;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(ELSE);
    }
    if (!hasError) {
ifstmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IF);
    }
    if (!hasError) {
ifstmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
ifstmt->setPosition(t);
    }
    if (!hasError) {
    exp = expression();
    }
    if (!hasError) {
ifstmt->setExpression(exp);
                ifstmt->setPosition(exp);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
ifstmt->setPosition(t);
    }
    if (!hasError) {
    stmt = statement();
    }
    if (!hasError) {
ifstmt->setStatement(stmt);
                ifstmt->setPosition(stmt);
    }
__ONERROR(ifstmt);
                return ifstmt;
assert(false);
}


AbstractExpression
                  * AlinousLang::expression() {AbstractExpression* exp = nullptr;
    if (!hasError) {
    if (!hasError) {
    exp = conditionalOrExpression();
    }
    }
    if (!hasError) {

    }
return exp;
assert(false);
}


AbstractExpression                  * AlinousLang::conditionalOrExpression() {Token* t = nullptr;
        ConditionalOrExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = conditionalAndExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LOGICAL_OR:{
        ;
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        goto end_label_16;
      }
      if (!hasError) {
      t = jj_consume_token(LOGICAL_OR);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new ConditionalOrExpression();
                                exp->setPosition(left);
                                exp->addExp(left);
                                left = exp;
                        }

                        exp->setPosition(t);
      }
      if (!hasError) {
      right = conditionalAndExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_16: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::conditionalAndExpression() {Token* t = nullptr;
        ConditionalAndExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = orExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LOGICAL_AND:{
        ;
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        goto end_label_17;
      }
      if (!hasError) {
      t = jj_consume_token(LOGICAL_AND);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new ConditionalAndExpression();
                                exp->setPosition(left);
                                exp->addExp(left);
                                left = exp;
                        }

                        exp->setPosition(t);
      }
      if (!hasError) {
      right = orExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_17: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::orExpression() {Token* t = nullptr;
        OrExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = exclusiveOrExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_OR:{
        ;
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        goto end_label_18;
      }
      if (!hasError) {
      t = jj_consume_token(BIT_OR);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new OrExpression();
                                exp->setPosition(left);
                                exp->addExp(left);
                                left = exp;
                        }

                        exp->setPosition(t);
      }
      if (!hasError) {
      right = exclusiveOrExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_18: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::exclusiveOrExpression() {Token* t = nullptr;
        ExclusiveOrExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = andExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 191:{
        ;
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        goto end_label_19;
      }
      if (!hasError) {
      t = jj_consume_token(191);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new ExclusiveOrExpression();
                                exp->setPosition(left);
                                exp->addExp(left);
                                left = exp;
                        }

                        exp->setPosition(t);
      }
      if (!hasError) {
      right = andExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_19: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::andExpression() {Token* t = nullptr;
        AndExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = equalityExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BIT_AND:{
        ;
        break;
        }
      default:
        jj_la1[38] = jj_gen;
        goto end_label_20;
      }
      if (!hasError) {
      t = jj_consume_token(BIT_AND);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new AndExpression();
                                exp->setPosition(left);
                                exp->addExp(left);
                                left = exp;
                        }

                        exp->setPosition(t);
      }
      if (!hasError) {
      right = equalityExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_20: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::equalityExpression() {Token* t = nullptr;
        EqualityExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = relationalExpression();
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CMP_EQUALS:
    case CMP_NOTEQUALS:{
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CMP_EQUALS:{
        if (!hasError) {
        t = jj_consume_token(CMP_EQUALS);
        }
        if (!hasError) {
exp = new EqualityExpression();
                                exp->setPosition(left);
                                exp->setLeft(left);
                                left = exp;

                                exp->setPosition(t);
                                exp->setOp(EqualityExpression::EQ);
        }
        break;
        }
      case CMP_NOTEQUALS:{
        if (!hasError) {
        t = jj_consume_token(CMP_NOTEQUALS);
        }
        if (!hasError) {
exp = new EqualityExpression();
                                exp->setPosition(left);
                                exp->setLeft(left);
                                left = exp;

                                exp->setPosition(t);
                                exp->setOp(EqualityExpression::NOT_EQ);
        }
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = relationalExpression();
      }
      if (!hasError) {
exp->setRight(right);
                        exp->setPosition(right);
      }
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::relationalExpression() {Token* t = nullptr;
        RelationalExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = shiftExpression();
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GT:
    case GEQ:
    case LT:
    case LEQ:{
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case GT:{
        if (!hasError) {
        t = jj_consume_token(GT);
        }
        if (!hasError) {
exp = new RelationalExpression();
                                exp->setPosition(left);
                                exp->setLeft(left);
                                left = exp;


                                exp->setPosition(t);
                                exp->setOp(RelationalExpression::GT);
        }
        break;
        }
      case GEQ:{
        if (!hasError) {
        t = jj_consume_token(GEQ);
        }
        if (!hasError) {
exp = new RelationalExpression();
                                exp->setPosition(left);
                                exp->setLeft(left);
                                left = exp;

                                exp->setPosition(t);
                                exp->setOp(RelationalExpression::GT_EQ);
        }
        break;
        }
      case LT:{
        if (!hasError) {
        t = jj_consume_token(LT);
        }
        if (!hasError) {
exp = new RelationalExpression();
                                exp->setPosition(left);
                                exp->setLeft(left);
                                left = exp;


                                exp->setPosition(t);
                                exp->setOp(RelationalExpression::LT);
        }
        break;
        }
      case LEQ:{
        if (!hasError) {
        t = jj_consume_token(LEQ);
        }
        if (!hasError) {
exp = new RelationalExpression();
                                exp->setPosition(left);
                                exp->setLeft(left);
                                left = exp;

                                exp->setPosition(t);
                                exp->setOp(RelationalExpression::LT_EQ);
        }
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = shiftExpression();
      }
      if (!hasError) {
exp->setRight(right);
                        exp->setPosition(right);
      }
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::shiftExpression() {Token* t = nullptr;
        ShiftExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = additiveExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case RSIGNEDSHIFT:
      case 192:{
        ;
        break;
        }
      default:
        jj_la1[43] = jj_gen;
        goto end_label_21;
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 192:{
        if (!hasError) {
        t = jj_consume_token(192);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new ShiftExpression();
                                        exp->setPosition(left);
                                        exp->addExp(left);
                                        left = exp;
                                }

                                exp->setPosition(t);
                                exp->addOpe(ShiftExpression::LEFT);
        }
        break;
        }
      case RSIGNEDSHIFT:{
        if (!hasError) {
        t = jj_consume_token(RSIGNEDSHIFT);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new ShiftExpression();
                                        exp->setPosition(left);
                                        exp->addExp(left);
                                        left = exp;
                                }

                                exp->setPosition(t);
                                exp->addOpe(ShiftExpression::RIGHT);
        }
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = additiveExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_21: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::additiveExpression() {Token* t = nullptr;
        AddExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = multiplicativeExpression();
    }
    if (!hasError) {
    while (!hasError) {
      if (jj_2_11(2)) {
        ;
      } else {
        goto end_label_22;
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        if (!hasError) {
        t = jj_consume_token(PLUS);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new AddExpression();
                                        exp->setPosition(left);
                                        exp->addExp(left);
                                        left = exp;
                                }

                                exp->setPosition(t);
                                exp->addOpe(AddExpression::ADD);
        }
        break;
        }
      case MINUS:{
        if (!hasError) {
        t = jj_consume_token(MINUS);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new AddExpression();
                                        exp->setPosition(left);
                                        exp->addExp(left);
                                        left = exp;
                                }

                                exp->setPosition(t);
                                exp->addOpe(AddExpression::SUB);
        }
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = multiplicativeExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_22: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::multiplicativeExpression() {Token* t = nullptr;
        MultiplicativeExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = negateExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:
      case DIV:
      case MODULO:{
        ;
        break;
        }
      default:
        jj_la1[46] = jj_gen;
        goto end_label_23;
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:{
        if (!hasError) {
        t = jj_consume_token(ASTERISK);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new MultiplicativeExpression();
                                        exp->setPosition(left);
                                        exp->addExp(left);
                                        left = exp;
                                }
                                exp->addOpe(MultiplicativeExpression::MUL);
                                exp->setPosition(t);
        }
        break;
        }
      case DIV:{
        if (!hasError) {
        t = jj_consume_token(DIV);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new MultiplicativeExpression();
                                        exp->setPosition(left);
                                        exp->addExp(left);
                                        left = exp;
                                }
                                exp->addOpe(MultiplicativeExpression::DIV);
                                exp->setPosition(t);
        }
        break;
        }
      case MODULO:{
        if (!hasError) {
        t = jj_consume_token(MODULO);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new MultiplicativeExpression();
                                        exp->setPosition(left);
                                        exp->addExp(left);
                                        left = exp;
                                }
                                exp->addOpe(MultiplicativeExpression::MOD);
                                exp->setPosition(t);
        }
        break;
        }
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = negateExpression();
      }
      if (!hasError) {
exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_23: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::negateExpression() {Token* t = nullptr;
        NegateExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MINUS:{
      if (!hasError) {
      t = jj_consume_token(MINUS);
      }
      if (!hasError) {
exp = new NegateExpression();
                        exp->setPosition(t);
                        left = exp;
      }
      break;
      }
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    right = postIncrementExpression();
    }
    if (!hasError) {
if(left==nullptr){
                        left = right;
                }
                else{
                        exp->setExpression(right);
                        exp->setPosition(right);
                }
    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::postIncrementExpression() {Token* t = nullptr;
        PostIncrementExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
    if (!hasError) {
    left = preIncrementExpression();
    }
    if (!hasError) {
    if (jj_2_12(2)) {
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MINUSMINUS:{
        if (!hasError) {
        t = jj_consume_token(MINUSMINUS);
        }
        if (!hasError) {
exp = new PostIncrementExpression();
                                exp->setExpression(left);
                                exp->setOpe(PostIncrementExpression::MINUS);
                                exp->setPosition(left);
                                exp->setPosition(t);
                                left = exp;
        }
        break;
        }
      case PLUSPLUS:{
        if (!hasError) {
        t = jj_consume_token(PLUSPLUS);
        }
        if (!hasError) {
exp = new PostIncrementExpression();
                                exp->setExpression(left);
                                exp->setOpe(PostIncrementExpression::PLUS);
                                exp->setPosition(left);
                                exp->setPosition(t);
                                left = exp;
        }
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
    } else {
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::preIncrementExpression() {Token* t = nullptr;
        PreIncrementExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PLUSPLUS:
    case MINUSMINUS:{
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MINUSMINUS:{
        if (!hasError) {
        t = jj_consume_token(MINUSMINUS);
        }
        if (!hasError) {
exp = new PreIncrementExpression();
                                exp->setOpe(PreIncrementExpression::MINUS);
                                exp->setPosition(t);
                                left = exp;
        }
        break;
        }
      case PLUSPLUS:{
        if (!hasError) {
        t = jj_consume_token(PLUSPLUS);
        }
        if (!hasError) {
exp = new PreIncrementExpression();
                                exp->setOpe(PreIncrementExpression::PLUS);
                                exp->setPosition(t);
                                left = exp;
        }
        break;
        }
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      break;
      }
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    right = bitReverseExpression();
    }
    if (!hasError) {
if(left==nullptr){
                        left = right;
                }
                else{
                        exp->setExpression(right);
                        exp->setPosition(right);
                }
    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::bitReverseExpression() {Token* t = nullptr;
        BitReverseExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 193:{
      if (!hasError) {
      t = jj_consume_token(193);
      }
      if (!hasError) {
exp = new BitReverseExpression();
                        exp->setPosition(t);
                        left = exp;
      }
      break;
      }
    default:
      jj_la1[52] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    right = notExpression();
    }
    if (!hasError) {
if(left==nullptr){
                        left = right;
                }
                else{
                        exp->setExpression(right);
                        exp->setPosition(right);
                }
    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::notExpression() {Token* t = nullptr;
        NotExpression* exp = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NOT:{
      if (!hasError) {
      t = jj_consume_token(NOT);
      }
      if (!hasError) {
exp = new NotExpression();
                        exp->setPosition(t);
                        left = exp;
      }
      break;
      }
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    right = castExpression();
    }
    if (!hasError) {
if(left==nullptr){
                        left = right;
                }
                else{
                        exp->setExpression(right);
                        exp->setPosition(right);
                }
    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::castExpression() {Token* t = nullptr;
        CastExpression* exp = nullptr;
        AbstractType* type = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    if (jj_2_13(3)) {
      if (!hasError) {
      if (!hasError) {
      t = jj_consume_token(L_PARENTHESIS);
      }
      if (!hasError) {
exp = new CastExpression();
                                exp->setPosition(t);
                                left = exp;
      }
      if (!hasError) {
      type = typeDeclare();
      }
      if (!hasError) {
exp->setType(type);
                                exp->setPosition(type);
      }
      if (!hasError) {
      t = jj_consume_token(R_PARENTHESIS);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      right = memberReferenceExpression();
      }
      if (!hasError) {
exp->setExpression(right);
                                exp->setPosition(right);
      }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case STRING_LITERAL:
      case SQL_STRING_LITERAL:
      case L_PARENTHESIS:
      case L_BRACKET:
      case L_BRACE:
      case NEW:
      case SUPER:
      case THIS:
      case TRUE:
      case FALSE:
      case INNER:
      case OUTER:
      case FULL:
      case JOIN:
      case CROSS:
      case VALUES:
      case GROUP:
      case BY:
      case HAVING:
      case ORDER:
      case ASC:
      case DESC:
      case LIMIT:
      case OFFSET:
      case ON:
      case AS:
      case DISTINCT:
      case SHARE:
      case NOWAIT:
      case OF:
      case IN:
      case BETWEEN:
      case CREATE:
      case DROP:
      case TABLE:
      case SQL_DEFAULT:
      case ADD:
      case RENAME:
      case COLUMN:
      case TO:
      case PRIMARY:
      case KEY:
      case UNIQUE:
      case CHECK:
      case RETURNS:
      case SETOF:
      case LANGUAGE:
      case REPLACE:
      case INDEX:
      case USING:
      case _NULL:
      case IDENTIFIER:{
        if (!hasError) {
        if (!hasError) {
        right = memberReferenceExpression();
        }
        if (!hasError) {
left = right;
        }
        }
        break;
        }
      default:
        jj_la1[54] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    }
    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::memberReferenceExpression() {MemberReferenceExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = arrayReferenceExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        ;
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        goto end_label_24;
      }
      if (!hasError) {
      jj_consume_token(DOT);
      }
      if (!hasError) {
      right = arrayReferenceExpression();
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new MemberReferenceExpression();
                                exp->addExp(left);
                                exp->setPosition(left);
                                left = exp;
                        }

                        exp->addExp(right);
                        exp->setPosition(right);
      }
    }
    end_label_24: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::arrayReferenceExpression() {ArrayReferenceExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractExpression* left = nullptr;
        AbstractExpression* right = nullptr;
    if (!hasError) {
    left = functionCallExpression();
    }
    if (!hasError) {
    while (!hasError) {
      if (jj_2_14(2)) {
        ;
      } else {
        goto end_label_25;
      }
      if (!hasError) {
      t = jj_consume_token(L_BRACKET);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new ArrayReferenceExpression();
                                exp->setExp(left);
                                exp->setPosition(left);
                                left = exp;
                        }
      }
      if (!hasError) {
      right = expression();
      }
      if (!hasError) {
      t = jj_consume_token(R_BRACKET);
      }
      if (!hasError) {
exp->addIndex(right);
                        exp->setPosition(t);
      }
    }
    end_label_25: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractExpression                  * AlinousLang::functionCallExpression() {FunctionCallExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractExpression* left = nullptr;
    if (!hasError) {
    left = primitive();
    }
    if (!hasError) {
    if (jj_2_15(2)) {
      if (!hasError) {
      t = jj_consume_token(L_PARENTHESIS);
      }
      if (!hasError) {
exp = new FunctionCallExpression();
                        exp->setName(left);
                        exp->setPosition(left);
                        exp->setPosition(t);

                        left = exp;
      }
      if (!hasError) {
      functionCallExpressionArg(exp);
      }
      if (!hasError) {
      t = jj_consume_token(R_PARENTHESIS);
      }
      if (!hasError) {
exp->setPosition(t);
      }
    } else {
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


void AlinousLang::functionCallExpressionArg(FunctionCallExpression* exp) {AbstractExpression* arg = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:
    case PLUSPLUS:
    case MINUSMINUS:
    case MINUS:
    case L_PARENTHESIS:
    case L_BRACKET:
    case L_BRACE:
    case NOT:
    case NEW:
    case SUPER:
    case THIS:
    case TRUE:
    case FALSE:
    case INNER:
    case OUTER:
    case FULL:
    case JOIN:
    case CROSS:
    case VALUES:
    case GROUP:
    case BY:
    case HAVING:
    case ORDER:
    case ASC:
    case DESC:
    case LIMIT:
    case OFFSET:
    case ON:
    case AS:
    case DISTINCT:
    case SHARE:
    case NOWAIT:
    case OF:
    case IN:
    case BETWEEN:
    case CREATE:
    case DROP:
    case TABLE:
    case SQL_DEFAULT:
    case ADD:
    case RENAME:
    case COLUMN:
    case TO:
    case PRIMARY:
    case KEY:
    case UNIQUE:
    case CHECK:
    case RETURNS:
    case SETOF:
    case LANGUAGE:
    case REPLACE:
    case INDEX:
    case USING:
    case _NULL:
    case IDENTIFIER:
    case 193:{
      if (!hasError) {
      arg = expression();
      }
      if (!hasError) {
exp->addArgument(arg);
                        exp->setPosition(arg);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[56] = jj_gen;
          goto end_label_26;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
exp->setPosition(t);
        }
        if (!hasError) {
        arg = expression();
        }
        if (!hasError) {
exp->addArgument(arg);
                                exp->setPosition(arg);
        }
      }
      end_label_26: ;
      }
      break;
      }
    default:
      jj_la1[57] = jj_gen;
      ;
    }
    }
}


AbstractExpression                  * AlinousLang::primitive() {AbstractExpression* exp = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_BRACE:{
      if (!hasError) {
      exp = jsonInitializerExpression();
      }
      break;
      }
    case L_BRACKET:{
      if (!hasError) {
      exp = jsonArrayExpression();
      }
      break;
      }
    case L_PARENTHESIS:{
      if (!hasError) {
      exp = parenthesisExpression();
      }
      break;
      }
    case NEW:{
      if (!hasError) {
      exp = allocationExpression();
      }
      break;
      }
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:
    case TRUE:
    case FALSE:
    case _NULL:{
      if (!hasError) {
      exp = literal();
      }
      break;
      }
    case SUPER:
    case THIS:
    case INNER:
    case OUTER:
    case FULL:
    case JOIN:
    case CROSS:
    case VALUES:
    case GROUP:
    case BY:
    case HAVING:
    case ORDER:
    case ASC:
    case DESC:
    case LIMIT:
    case OFFSET:
    case ON:
    case AS:
    case DISTINCT:
    case SHARE:
    case NOWAIT:
    case OF:
    case IN:
    case BETWEEN:
    case CREATE:
    case DROP:
    case TABLE:
    case SQL_DEFAULT:
    case ADD:
    case RENAME:
    case COLUMN:
    case TO:
    case PRIMARY:
    case KEY:
    case UNIQUE:
    case CHECK:
    case RETURNS:
    case SETOF:
    case LANGUAGE:
    case REPLACE:
    case INDEX:
    case USING:
    case IDENTIFIER:{
      if (!hasError) {
      exp = variableIdentifier();
      }
      break;
      }
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
return exp;
assert(false);
}


AllocationExpression                    * AlinousLang::allocationExpression() {AllocationExpression* exp = nullptr;
        ConstructorCall* func = nullptr;
        ConstructorArray* ar = nullptr;
        Token* t = nullptr;

        AbstractType* type = nullptr;
    if (!hasError) {
    t = jj_consume_token(NEW);
    }
    if (!hasError) {
exp = new AllocationExpression();
                exp->setPosition(t);
    }
    if (!hasError) {
    type = typeBody();
    }
    if (!hasError) {
exp->setPosition(type);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_PARENTHESIS:{
      if (!hasError) {
      if (!hasError) {
      func = constructorCallExpression(type);
      }
      if (!hasError) {
exp->setExpression(func);
                                exp->setPosition(func);
      }
      }
      break;
      }
    default:
      jj_la1[59] = jj_gen;
      if (!hasError) {
      if (!hasError) {
      ar = constructorArray(type);
      }
      if (!hasError) {
exp->setPosition(ar);
                                exp->setConstructorArray(ar);
      }
      }
    }
    }
__ONERROR(exp);
                return exp;
assert(false);
}


ConstructorArray                * AlinousLang::constructorArray(AbstractType* type) {ConstructorArray* exp = new ConstructorArray();
        Token* t = nullptr;
        AbstractExpression* dim = nullptr;

        exp->setValId(type);
        exp->setPosition(type);
    if (!hasError) {
    while (!hasError) {
      if (jj_2_16(2)) {
        ;
      } else {
        goto end_label_27;
      }
      if (!hasError) {
      t = jj_consume_token(L_BRACKET);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      dim = expression();
      }
      if (!hasError) {
exp->setPosition(dim);
                        exp->addDim(dim);
      }
      if (!hasError) {
      t = jj_consume_token(R_BRACKET);
      }
      if (!hasError) {
exp->setPosition(t);
      }
    }
    end_label_27: ;
    }
    if (!hasError) {

    }
__ONERROR(exp);
                return exp;
assert(false);
}


ConstructorCall               * AlinousLang::constructorCallExpression(AbstractType* type) {ConstructorCall* exp = new ConstructorCall();
        Token* t = nullptr;

        exp->setName(type);
        exp->setPosition(type);
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
    if (!hasError) {
    constructorCallExpressionArg(exp);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
__ONERROR(exp);
                return exp;
assert(false);
}


void AlinousLang::constructorCallExpressionArg(ConstructorCall* exp) {AbstractExpression* arg = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:
    case PLUSPLUS:
    case MINUSMINUS:
    case MINUS:
    case L_PARENTHESIS:
    case L_BRACKET:
    case L_BRACE:
    case NOT:
    case NEW:
    case SUPER:
    case THIS:
    case TRUE:
    case FALSE:
    case INNER:
    case OUTER:
    case FULL:
    case JOIN:
    case CROSS:
    case VALUES:
    case GROUP:
    case BY:
    case HAVING:
    case ORDER:
    case ASC:
    case DESC:
    case LIMIT:
    case OFFSET:
    case ON:
    case AS:
    case DISTINCT:
    case SHARE:
    case NOWAIT:
    case OF:
    case IN:
    case BETWEEN:
    case CREATE:
    case DROP:
    case TABLE:
    case SQL_DEFAULT:
    case ADD:
    case RENAME:
    case COLUMN:
    case TO:
    case PRIMARY:
    case KEY:
    case UNIQUE:
    case CHECK:
    case RETURNS:
    case SETOF:
    case LANGUAGE:
    case REPLACE:
    case INDEX:
    case USING:
    case _NULL:
    case IDENTIFIER:
    case 193:{
      if (!hasError) {
      arg = expression();
      }
      if (!hasError) {
exp->addArgument(arg);
                        exp->setPosition(arg);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[60] = jj_gen;
          goto end_label_28;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
exp->setPosition(t);
        }
        if (!hasError) {
        arg = expression();
        }
        if (!hasError) {
exp->addArgument(arg);
                                exp->setPosition(arg);
        }
      }
      end_label_28: ;
      }
      break;
      }
    default:
      jj_la1[61] = jj_gen;
      ;
    }
    }
}


ParenthesisExpression                     * AlinousLang::parenthesisExpression() {ParenthesisExpression* exp = new ParenthesisExpression();
        AbstractExpression* e = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
    if (!hasError) {
    e = expression();
    }
    if (!hasError) {
exp->setExp(e);
                exp->setPosition(e);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
__ONERROR(exp);
                return exp;
assert(false);
}


VariableIdentifier                  * AlinousLang::variableIdentifier() {VariableIdentifier* valId = new VariableIdentifier();
        Token* t = nullptr;
    if (!hasError) {
    t = identifierName();
    }
    if (!hasError) {
valId->setName(_STR(t));
    }
__ONERROR(valId);
                return valId;
assert(false);
}


Token     * AlinousLang::identifierName() {Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      break;
      }
    case THIS:{
      if (!hasError) {
      t = jj_consume_token(THIS);
      }
      break;
      }
    case SUPER:{
      if (!hasError) {
      t = jj_consume_token(SUPER);
      }
      break;
      }
    case INNER:{
      if (!hasError) {
      t = jj_consume_token(INNER);
      }
      break;
      }
    case OUTER:{
      if (!hasError) {
      t = jj_consume_token(OUTER);
      }
      break;
      }
    case FULL:{
      if (!hasError) {
      t = jj_consume_token(FULL);
      }
      break;
      }
    case JOIN:{
      if (!hasError) {
      t = jj_consume_token(JOIN);
      }
      break;
      }
    case VALUES:{
      if (!hasError) {
      t = jj_consume_token(VALUES);
      }
      break;
      }
    case CROSS:{
      if (!hasError) {
      t = jj_consume_token(CROSS);
      }
      break;
      }
    case GROUP:{
      if (!hasError) {
      t = jj_consume_token(GROUP);
      }
      break;
      }
    case BY:{
      if (!hasError) {
      t = jj_consume_token(BY);
      }
      break;
      }
    case HAVING:{
      if (!hasError) {
      t = jj_consume_token(HAVING);
      }
      break;
      }
    case ORDER:{
      if (!hasError) {
      t = jj_consume_token(ORDER);
      }
      break;
      }
    case ASC:{
      if (!hasError) {
      t = jj_consume_token(ASC);
      }
      break;
      }
    case DESC:{
      if (!hasError) {
      t = jj_consume_token(DESC);
      }
      break;
      }
    case LIMIT:{
      if (!hasError) {
      t = jj_consume_token(LIMIT);
      }
      break;
      }
    case OFFSET:{
      if (!hasError) {
      t = jj_consume_token(OFFSET);
      }
      break;
      }
    case ON:{
      if (!hasError) {
      t = jj_consume_token(ON);
      }
      break;
      }
    case AS:{
      if (!hasError) {
      t = jj_consume_token(AS);
      }
      break;
      }
    case DISTINCT:{
      if (!hasError) {
      t = jj_consume_token(DISTINCT);
      }
      break;
      }
    case SHARE:{
      if (!hasError) {
      t = jj_consume_token(SHARE);
      }
      break;
      }
    case NOWAIT:{
      if (!hasError) {
      t = jj_consume_token(NOWAIT);
      }
      break;
      }
    case OF:{
      if (!hasError) {
      t = jj_consume_token(OF);
      }
      break;
      }
    case IN:{
      if (!hasError) {
      t = jj_consume_token(IN);
      }
      break;
      }
    case BETWEEN:{
      if (!hasError) {
      t = jj_consume_token(BETWEEN);
      }
      break;
      }
    case CREATE:{
      if (!hasError) {
      t = jj_consume_token(CREATE);
      }
      break;
      }
    case DROP:{
      if (!hasError) {
      t = jj_consume_token(DROP);
      }
      break;
      }
    case TABLE:{
      if (!hasError) {
      t = jj_consume_token(TABLE);
      }
      break;
      }
    case SQL_DEFAULT:{
      if (!hasError) {
      t = jj_consume_token(SQL_DEFAULT);
      }
      break;
      }
    case ADD:{
      if (!hasError) {
      t = jj_consume_token(ADD);
      }
      break;
      }
    case RENAME:{
      if (!hasError) {
      t = jj_consume_token(RENAME);
      }
      break;
      }
    case COLUMN:{
      if (!hasError) {
      t = jj_consume_token(COLUMN);
      }
      break;
      }
    case TO:{
      if (!hasError) {
      t = jj_consume_token(TO);
      }
      break;
      }
    case PRIMARY:{
      if (!hasError) {
      t = jj_consume_token(PRIMARY);
      }
      break;
      }
    case KEY:{
      if (!hasError) {
      t = jj_consume_token(KEY);
      }
      break;
      }
    case UNIQUE:{
      if (!hasError) {
      t = jj_consume_token(UNIQUE);
      }
      break;
      }
    case CHECK:{
      if (!hasError) {
      t = jj_consume_token(CHECK);
      }
      break;
      }
    case RETURNS:{
      if (!hasError) {
      t = jj_consume_token(RETURNS);
      }
      break;
      }
    case SETOF:{
      if (!hasError) {
      t = jj_consume_token(SETOF);
      }
      break;
      }
    case LANGUAGE:{
      if (!hasError) {
      t = jj_consume_token(LANGUAGE);
      }
      break;
      }
    case REPLACE:{
      if (!hasError) {
      t = jj_consume_token(REPLACE);
      }
      break;
      }
    case INDEX:{
      if (!hasError) {
      t = jj_consume_token(INDEX);
      }
      break;
      }
    case USING:{
      if (!hasError) {
      t = jj_consume_token(USING);
      }
      break;
      }
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
return t;
assert(false);
}


AbstractExpression                  * AlinousLang::literal() {AbstractExpression* lit = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _NULL:{
      if (!hasError) {
      lit = nullLiteral();
      }
      break;
      }
    case TRUE:
    case FALSE:{
      if (!hasError) {
      lit = booleanLiteral();
      }
      break;
      }
    case INTEGER_LITERAL:{
      if (!hasError) {
      lit = numberLiteral();
      }
      break;
      }
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:{
      if (!hasError) {
      lit = literalExpression();
      }
      break;
      }
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
return lit;
assert(false);
}


NullLiteral           * AlinousLang::nullLiteral() {NullLiteral* lit = new NullLiteral();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(_NULL);
    }
    if (!hasError) {
lit->setPositions(t, t);
    }
__ONERROR(lit);
                return lit;
assert(false);
}


NumberLiteral             * AlinousLang::numberLiteral() {NumberLiteral* lit = new NumberLiteral();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(INTEGER_LITERAL);
    }
    if (!hasError) {
lit->setValue(_STR(t));
                lit->setPositions(t, t);
    }
__ONERROR(lit);
                return lit;
assert(false);
}


BooleanLiteral              * AlinousLang::booleanLiteral() {BooleanLiteral* lit = new BooleanLiteral();
        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      if (!hasError) {
      t = jj_consume_token(TRUE);
      }
      if (!hasError) {
lit->setValue(true);
      }
      break;
      }
    case FALSE:{
      if (!hasError) {
      t = jj_consume_token(FALSE);
      }
      if (!hasError) {
lit->setValue(false);
      }
      break;
      }
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {
lit->setPositions(t, t);
    }
__ONERROR(lit);
                return lit;
assert(false);
}


LiteralExpression                 * AlinousLang::literalExpression() {LiteralExpression* lit = new LiteralExpression();
        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_LITERAL:{
      if (!hasError) {
      t = jj_consume_token(STRING_LITERAL);
      }
      if (!hasError) {
lit->setString(_STR(t), true);
      }
      break;
      }
    case SQL_STRING_LITERAL:{
      if (!hasError) {
      t = jj_consume_token(SQL_STRING_LITERAL);
      }
      if (!hasError) {
lit->setString(_STR(t), false);
      }
      break;
      }
    default:
      jj_la1[65] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {
lit->setPositions(t, t);
    }
__ONERROR(lit);
                return lit;
assert(false);
}


AbstractSQLStatement
                    * AlinousLang::ddlStatement() {AbstractSQLStatement* stmt = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case CREATE:{
      if (!hasError) {
      stmt = createTableStatement();
      }
      break;
      }
    case DROP:{
      if (!hasError) {
      stmt = dropTableStatement();
      }
      break;
      }
    case ALTER:{
      if (!hasError) {
      stmt = alterTableStatement();
      }
      break;
      }
    default:
      jj_la1[66] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
return stmt;
assert(false);
}


AlterTableStatement                   * AlinousLang::alterTableStatement() {AlterTableStatement* stmt = new AlterTableStatement();
        TableIdentifier* tableId = nullptr;
        AbstractAlterDdlCommand* cmd = nullptr;
        Token* t = null;
    if (!hasError) {
    t = jj_consume_token(ALTER);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(TABLE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    tableId = tableIdentifier();
    }
    if (!hasError) {
stmt->setPosition(tableId);
                stmt->setTableId(tableId);
    }
    if (!hasError) {
    cmd = alterCommands();
    }
    if (!hasError) {
stmt->setPosition(cmd);
                stmt->setCommand(cmd);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


AbstractAlterDdlCommand                       * AlinousLang::alterCommands() {AbstractAlterDdlCommand* cmd = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ADD:{
      if (!hasError) {
      cmd = addAlterCommands();
      }
      break;
      }
    case DROP:{
      if (!hasError) {
      cmd = dropAlterCommands();
      }
      break;
      }
    case MODIFY:{
      if (!hasError) {
      cmd = alterModifyCommand();
      }
      break;
      }
    case RENAME:{
      if (!hasError) {
      cmd = alterRenameCommands();
      }
      break;
      }
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AbstractAlterDdlCommand                       * AlinousLang::alterRenameCommands() {AbstractAlterDdlCommand* cmd = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(RENAME);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      if (!hasError) {
      cmd = alterRenameColumnCommand(t);
      }
      break;
      }
    case TO:{
      if (!hasError) {
      cmd = alterRenameTableCommand(t);
      }
      break;
      }
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterRenameTableCommand                       * AlinousLang::alterRenameTableCommand(Token* t) {AlterRenameTableCommand* cmd = new AlterRenameTableCommand();
        cmd->setPosition(t);

        TableIdentifier* tableId = nullptr;
    if (!hasError) {
    t = jj_consume_token(TO);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    tableId = tableIdentifier();
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->setNewName(tableId);
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterRenameColumnCommand                        * AlinousLang::alterRenameColumnCommand(Token* t) {AlterRenameColumnCommand* cmd = new AlterRenameColumnCommand();
        cmd->setPosition(t);
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->setLastName(_STR(t));
    }
    if (!hasError) {
    t = jj_consume_token(TO);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->setNewName(_STR(t));
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterModifyCommand                  * AlinousLang::alterModifyCommand() {AlterModifyCommand* cmd = new AlterModifyCommand();
        DdlColumnDescriptor* desc = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(MODIFY);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    desc = ddlColumnDescriptor();
    }
    if (!hasError) {
cmd->setPosition(desc);
                cmd->setColumnDescriptor(desc);
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AbstractAlterDdlCommand                       * AlinousLang::dropAlterCommands() {AbstractAlterDdlCommand* cmd = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(DROP);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INDEX:{
      if (!hasError) {
      cmd = alterDropIndexCommand(t);
      }
      break;
      }
    case COLUMN:
    case IDENTIFIER:{
      if (!hasError) {
      cmd = alterDropColumnCommand(t);
      }
      break;
      }
    case PRIMARY:{
      if (!hasError) {
      cmd = alterDropPrimaryKeyCommand(t);
      }
      break;
      }
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterDropPrimaryKeyCommand                          * AlinousLang::alterDropPrimaryKeyCommand(Token* t) {AlterDropPrimaryKeyCommand* cmd = new AlterDropPrimaryKeyCommand();
        cmd->setPosition(t);
    if (!hasError) {
    t = jj_consume_token(PRIMARY);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(KEY);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterDropIndexCommand                     * AlinousLang::alterDropIndexCommand(Token* t) {AlterDropIndexCommand* cmd = new AlterDropIndexCommand();
        cmd->setPosition(t);
    if (!hasError) {
    t = jj_consume_token(INDEX);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->setName(_STR(t));
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterDropColumnCommand                      * AlinousLang::alterDropColumnCommand(Token* t) {AlterDropColumnCommand* cmd = new AlterDropColumnCommand();
        cmd->setPosition(t);
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLUMN:{
      if (!hasError) {
      t = jj_consume_token(COLUMN);
      }
      if (!hasError) {
cmd->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[70] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->setName(_STR(t));
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AbstractAlterDdlCommand                       * AlinousLang::addAlterCommands() {AbstractAlterDdlCommand* cmd = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(ADD);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQUE:
    case INDEX:{
      if (!hasError) {
      cmd = alterAddIndexCommand(t);
      }
      break;
      }
    case COLUMN:
    case IDENTIFIER:{
      if (!hasError) {
      cmd = alterAddColumnCommand(t);
      }
      break;
      }
    case PRIMARY:{
      if (!hasError) {
      cmd = alterAddPrimaryKeyCommand(t);
      }
      break;
      }
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterAddPrimaryKeyCommand                         * AlinousLang::alterAddPrimaryKeyCommand(Token* t) {AlterAddPrimaryKeyCommand* cmd = new AlterAddPrimaryKeyCommand();

        cmd->setPosition(t);
    if (!hasError) {
    t = jj_consume_token(PRIMARY);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(KEY);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->addColumn(_STR(t));
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[72] = jj_gen;
        goto end_label_29;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
cmd->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
cmd->setPosition(t);
                        cmd->addColumn(_STR(t));
      }
    }
    end_label_29: ;
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterAddColumnCommand                     * AlinousLang::alterAddColumnCommand(Token* __t) {AlterAddColumnCommand* cmd = new AlterAddColumnCommand();
        DdlColumnDescriptor* desc = nullptr;
        cmd->setPosition(__t);

        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COLUMN:{
      if (!hasError) {
      t = jj_consume_token(COLUMN);
      }
      if (!hasError) {
cmd->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    desc = ddlColumnDescriptor();
    }
    if (!hasError) {
cmd->setPosition(desc);
                cmd->setColumnDescriptor(desc);
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


AlterAddIndexCommand                    * AlinousLang::alterAddIndexCommand(Token* t) {AlterAddIndexCommand* cmd = new AlterAddIndexCommand();
        cmd->setPosition(t);
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQUE:{
      if (!hasError) {
      t = jj_consume_token(UNIQUE);
      }
      if (!hasError) {
cmd->setPosition(t);
                        cmd->setUnique(true);
      }
      break;
      }
    default:
      jj_la1[74] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(INDEX);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->setName(_STR(t));
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
cmd->setPosition(t);
                cmd->addColumn(_STR(t));
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[75] = jj_gen;
        goto end_label_30;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
cmd->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
cmd->setPosition(t);
                        cmd->addColumn(_STR(t));
      }
    }
    end_label_30: ;
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
cmd->setPosition(t);
    }
__ONERROR(cmd);
                return cmd;
assert(false);
}


CreateTableStatement                    * AlinousLang::createTableStatement() {CreateTableStatement* stmt = new CreateTableStatement();
        DdlColumnDescriptor* desc = nullptr;
        Token* t = null;
    if (!hasError) {
    t = jj_consume_token(CREATE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(TABLE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
stmt->setName(_STR(t));
                stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      if (!hasError) {
      // columns
                      desc = ddlColumnDescriptor();
      }
      if (!hasError) {
stmt->addColumn(desc);
                        stmt->setPosition(desc);
      }
      if (!hasError) {
      while (!hasError) {
        if (jj_2_17(2)) {
          ;
        } else {
          goto end_label_31;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
stmt->setPosition(t);
        }
        if (!hasError) {
        desc = ddlColumnDescriptor();
        }
        if (!hasError) {
stmt->addColumn(desc);
                                stmt->setPosition(desc);
        }
      }
      end_label_31: ;
      }
      break;
      }
    default:
      jj_la1[76] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:
    case PRIMARY:{
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        break;
        }
      default:
        jj_la1[77] = jj_gen;
        ;
      }
      }
      if (!hasError) {
      t = jj_consume_token(PRIMARY);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(KEY);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(L_PARENTHESIS);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
stmt->addPrimaryKey(_STR(t));
                        stmt->setPosition(t);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[78] = jj_gen;
          goto end_label_32;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
stmt->setPosition(t);
        }
        if (!hasError) {
        t = jj_consume_token(IDENTIFIER);
        }
        if (!hasError) {
stmt->addPrimaryKey(_STR(t));
                                stmt->setPosition(t);
        }
      }
      end_label_32: ;
      }
      if (!hasError) {
      t = jj_consume_token(R_PARENTHESIS);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[79] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


DdlColumnDescriptor                   * AlinousLang::ddlColumnDescriptor() {DdlColumnDescriptor* desc = new DdlColumnDescriptor();
        ColumnTypeDescriptor* typeDesc = nullptr;
        AbstractSQLExpression* val = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(IDENTIFIER);
    }
    if (!hasError) {
desc->setName(_STR(t));
                desc->setPosition(t);
    }
    if (!hasError) {
    typeDesc = columnTypeDescriptor();
    }
    if (!hasError) {
desc->setColumnType(typeDesc);
                desc->setPosition(typeDesc);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SQL_NOT:{
      if (!hasError) {
      t = jj_consume_token(SQL_NOT);
      }
      if (!hasError) {
desc->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(_NULL);
      }
      if (!hasError) {
desc->setNotNull(true);
                        desc->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[80] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNIQUE:{
      if (!hasError) {
      t = jj_consume_token(UNIQUE);
      }
      if (!hasError) {
desc->setUnique(true);
                        desc->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[81] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SQL_DEFAULT:{
      if (!hasError) {
      t = jj_consume_token(SQL_DEFAULT);
      }
      if (!hasError) {
desc->setPosition(t);
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case SQL_STRING_LITERAL:{
        if (!hasError) {
        val = sqlLiteral();
        }
        break;
        }
      case TRUE:
      case FALSE:{
        if (!hasError) {
        val = sqlBooleanLiteral();
        }
        break;
        }
      case _NULL:{
        if (!hasError) {
        val = sqlNullLiteral();
        }
        break;
        }
      default:
        jj_la1[82] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
desc->setDefaultValue(val);
                        desc->setPosition(val);
      }
      break;
      }
    default:
      jj_la1[83] = jj_gen;
      ;
    }
    }
__ONERROR(desc);
                return desc;
assert(false);
}


ColumnTypeDescriptor                    * AlinousLang::columnTypeDescriptor() {ColumnTypeDescriptor* typeDesc = new ColumnTypeDescriptor();
        AbstractSQLExpression* val = nullptr;
        Token* t1 = nullptr;
        Token* t2 = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      if (!hasError) {
      t1 = jj_consume_token(IDENTIFIER);
      }
      break;
      }
    case INT:{
      if (!hasError) {
      t1 = jj_consume_token(INT);
      }
      break;
      }
    case BYTE:{
      if (!hasError) {
      t1 = jj_consume_token(BYTE);
      }
      break;
      }
    case SHORT:{
      if (!hasError) {
      t1 = jj_consume_token(SHORT);
      }
      break;
      }
    case LONG:{
      if (!hasError) {
      t1 = jj_consume_token(LONG);
      }
      break;
      }
    default:
      jj_la1[84] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {
typeDesc->setTypeName(_STR(t1));
                typeDesc->setPosition(t1);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_PARENTHESIS:{
      if (!hasError) {
      t2 = jj_consume_token(L_PARENTHESIS);
      }
      if (!hasError) {
typeDesc->setPosition(t2);
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER_LITERAL:
      case CHARACTER_LITERAL:
      case SQL_STRING_LITERAL:{
        if (!hasError) {
        val = sqlLiteral();
        }
        break;
        }
      case TRUE:
      case FALSE:{
        if (!hasError) {
        val = sqlBooleanLiteral();
        }
        break;
        }
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
typeDesc->setLength(val);
                        typeDesc->setPosition(val);
      }
      if (!hasError) {
      t2 = jj_consume_token(R_PARENTHESIS);
      }
      if (!hasError) {
typeDesc->setPosition(t2);
      }
      break;
      }
    default:
      jj_la1[86] = jj_gen;
      ;
    }
    }
__ONERROR(typeDesc);
                return typeDesc;
assert(false);
}


DropTableStatement                  * AlinousLang::dropTableStatement() {DropTableStatement* stmt = new DropTableStatement();
        Token* t = null;
        TableIdentifier* tableId = nullptr;
    if (!hasError) {
    t = jj_consume_token(DROP);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(TABLE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    tableId = tableIdentifier();
    }
    if (!hasError) {
stmt->setTableId(tableId);
                stmt->setPosition(tableId);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


AbstractSQLStatement
                    * AlinousLang::sqlDmlStatement() {AbstractSQLStatement* stmt = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BEGIN:{
      if (!hasError) {
      stmt = beginStatement();
      }
      break;
      }
    case COMMIT:{
      if (!hasError) {
      stmt = commitStatement();
      }
      break;
      }
    case ROLLBACK:{
      if (!hasError) {
      stmt = rollbackStatement();
      }
      break;
      }
    case DELETE:{
      if (!hasError) {
      stmt = deleteStatement();
      }
      break;
      }
    case INSERT:{
      if (!hasError) {
      stmt = insertStatement();
      }
      break;
      }
    case UPDATE:{
      if (!hasError) {
      stmt = updateStatement();
      }
      break;
      }
    case SELECT:{
      if (!hasError) {
      stmt = selectStatement();
      }
      break;
      }
    default:
      jj_la1[87] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
return stmt;
assert(false);
}


SelectStatement               * AlinousLang::selectStatement() {SelectStatement* stmt = new SelectStatement();
        Token* t = nullptr;
        SQLSelectTargetList* expList = nullptr;
        SQLFrom* from = nullptr;
        SQLWhere* where = nullptr;
        SQLOrderBy* orderBy = nullptr;
        SQLGroupBy* groupBy = nullptr;
        SQLLimitOffset* limitOffset = nullptr;
    if (!hasError) {
    t = jj_consume_token(SELECT);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    expList = sqlSelectTargetList();
    }
    if (!hasError) {
stmt->setList(expList);
                stmt->setPosition(expList);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTO:{
      if (!hasError) {
      t = jj_consume_token(INTO);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
stmt->setintoVar(_STR(t));
                        stmt->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[88] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    from = sqlFrom();
    }
    if (!hasError) {
stmt->setFrom(from);
                stmt->setPosition(from);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WHERE:{
      if (!hasError) {
      where = sqlWhere();
      }
      if (!hasError) {
stmt->setWhere(where);
                        stmt->setPosition(where);
      }
      break;
      }
    default:
      jj_la1[89] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GROUP:{
      if (!hasError) {
      groupBy = sqlGroupBy();
      }
      if (!hasError) {
stmt->setGroupBy(groupBy);
                        stmt->setPosition(groupBy);
      }
      break;
      }
    default:
      jj_la1[90] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ORDER:{
      if (!hasError) {
      orderBy = sqlOrderBy();
      }
      if (!hasError) {
stmt->setOrderBy(orderBy);
                        stmt->setPosition(orderBy);
      }
      break;
      }
    default:
      jj_la1[91] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    limitOffset = sqlLimitOffset();
    }
    if (!hasError) {
stmt->setLimitOffset(limitOffset);
                stmt->setPosition(limitOffset);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLSelectTargetList                   * AlinousLang::sqlSelectTargetList() {SQLSelectTargetList* stmt = new SQLSelectTargetList();
        Token* t = nullptr;
        SQLSelectTarget* target = nullptr;
    if (!hasError) {
    target = sqlSelectTarget();
    }
    if (!hasError) {
stmt->addTarget(target);
                stmt->setPosition(target);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[92] = jj_gen;
        goto end_label_33;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      target = sqlSelectTarget();
      }
      if (!hasError) {
stmt->addTarget(target);
                        stmt->setPosition(target);
      }
    }
    end_label_33: ;
    }
    if (!hasError) {

    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLSelectTarget               * AlinousLang::sqlSelectTarget() {SQLSelectTarget* stmt = new SQLSelectTarget();
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
    if (!hasError) {
    if (!hasError) {
    if (!hasError) {
    exp = sqlExpression();
    }
    if (!hasError) {
stmt->setExpression(exp);
                                stmt->setPosition(exp);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AS:{
      if (!hasError) {
      t = jj_consume_token(AS);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
stmt->setAsName(_STR(t));
                                        stmt->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[93] = jj_gen;
      ;
    }
    }
    }
    }
    if (!hasError) {

    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLGroupBy          * AlinousLang::sqlGroupBy() {SQLGroupBy* stmt = new SQLGroupBy();
        Token* t = nullptr;
        SQLColumnsList* columns = nullptr;
        SQLHaving* having = nullptr;
    if (!hasError) {
    t = jj_consume_token(GROUP);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(BY);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    columns = sqlColumnsList();
    }
    if (!hasError) {
stmt->setList(columns);
                stmt->setPosition(columns);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case HAVING:{
      if (!hasError) {
      having = sqlHaving();
      }
      if (!hasError) {
stmt->setHaving(having);
                        stmt->setPosition(having);
      }
      break;
      }
    default:
      jj_la1[94] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLHaving         * AlinousLang::sqlHaving() {SQLHaving* stmt = new SQLHaving();
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
    if (!hasError) {
    t = jj_consume_token(HAVING);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    exp = sqlExpression();
    }
    if (!hasError) {
stmt->setExpression(exp);
                stmt->setPosition(exp);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLOrderBy          * AlinousLang::sqlOrderBy() {SQLOrderBy* stmt = new SQLOrderBy();
        Token* t = nullptr;
        SQLColumnsList* columns = nullptr;
    if (!hasError) {
    t = jj_consume_token(ORDER);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(BY);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    columns = sqlColumnsList();
    }
    if (!hasError) {
stmt->setList(columns);
                stmt->setPosition(columns);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLLimitOffset              * AlinousLang::sqlLimitOffset() {SQLLimitOffset* stmt = new SQLLimitOffset();
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LIMIT:{
      if (!hasError) {
      t = jj_consume_token(LIMIT);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      exp = sqlExpression();
      }
      if (!hasError) {
stmt->setLimit(exp);
                        stmt->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[95] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OFFSET:{
      if (!hasError) {
      t = jj_consume_token(OFFSET);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      exp = sqlExpression();
      }
      if (!hasError) {
stmt->setOffset(exp);
                        stmt->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[96] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


UpdateStatement               * AlinousLang::updateStatement() {UpdateStatement* stmt = new UpdateStatement();
        Token* t = nullptr;
        TableIdentifier* tableId = nullptr;
        SQLSet* set = nullptr;
        SQLWhere* where = nullptr;
    if (!hasError) {
    t = jj_consume_token(UPDATE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    tableId = tableIdentifier();
    }
    if (!hasError) {
stmt->setTable(tableId);
                stmt->setPosition(tableId);
    }
    if (!hasError) {
    set = sqlSet();
    }
    if (!hasError) {
stmt->setSet(set);
                stmt->setPosition(set);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WHERE:{
      if (!hasError) {
      where = sqlWhere();
      }
      if (!hasError) {
stmt->setWhere(where);
                        stmt->setPosition(where);
      }
      break;
      }
    default:
      jj_la1[97] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLSet      * AlinousLang::sqlSet() {SQLSet* stmt = new SQLSet();
        Token* t = nullptr;
        SQLSetPair* pair = nullptr;
    if (!hasError) {
    t = jj_consume_token(SET);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    pair = sqlSetPair();
    }
    if (!hasError) {
stmt->addPair(pair);
                stmt->setPosition(pair);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[98] = jj_gen;
        goto end_label_34;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      pair = sqlSetPair();
      }
      if (!hasError) {
stmt->addPair(pair);
                        stmt->setPosition(pair);
      }
    }
    end_label_34: ;
    }
    if (!hasError) {

    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLSetPair          * AlinousLang::sqlSetPair() {SQLSetPair* stmt = new SQLSetPair();
        Token* t = nullptr;
        SQLColumnIdentifier* colId = nullptr;
        AbstractSQLExpression* ex = nullptr;
    if (!hasError) {
    colId = sqlColumnIdentifier();
    }
    if (!hasError) {
stmt->setColumn(colId);
                stmt->setPosition(colId);
    }
    if (!hasError) {
    t = jj_consume_token(EQUALS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    ex = sqlExpression();
    }
    if (!hasError) {
stmt->setExpression(ex);
                stmt->setPosition(ex);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


InsertStatement               * AlinousLang::insertStatement() {InsertStatement* stmt = new InsertStatement();
        Token* t = nullptr;
        TableIdentifier* tableId = nullptr;
        SQLColumnsList* columns = nullptr;
        SQLExpressionList* expList = nullptr;
    if (!hasError) {
    t = jj_consume_token(INSERT);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(INTO);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    tableId = tableIdentifier();
    }
    if (!hasError) {
stmt->setTable(tableId);
                stmt->setPosition(tableId);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_PARENTHESIS:{
      if (!hasError) {
      t = jj_consume_token(L_PARENTHESIS);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      columns = sqlColumnsList();
      }
      if (!hasError) {
stmt->setColumns(columns);
                        stmt->setPosition(columns);
      }
      if (!hasError) {
      t = jj_consume_token(R_PARENTHESIS);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[99] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(VALUES);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    expList = sqlExpressionList();
    }
    if (!hasError) {
stmt->setExpressionList(expList);
                stmt->setPosition(expList);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLColumnsList              * AlinousLang::sqlColumnsList() {SQLColumnsList* stmt = new SQLColumnsList();
        Token* t = nullptr;
        SQLColumnIdentifier* colId = nullptr;
    if (!hasError) {
    colId = sqlColumnIdentifier();
    }
    if (!hasError) {
stmt->addColumn(colId);
                stmt->setPosition(colId);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[100] = jj_gen;
        goto end_label_35;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
stmt->setPosition(t);
      }
      if (!hasError) {
      colId = sqlColumnIdentifier();
      }
      if (!hasError) {
stmt->addColumn(colId);
                        stmt->setPosition(colId);
      }
    }
    end_label_35: ;
    }
    if (!hasError) {

    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


DeleteStatement               * AlinousLang::deleteStatement() {DeleteStatement* stmt = new DeleteStatement();
        Token* t = nullptr;
        SQLFrom* from = nullptr;
        SQLWhere* where = nullptr;
    if (!hasError) {
    t = jj_consume_token(DELETE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    from = sqlFrom();
    }
    if (!hasError) {
stmt->setFrom(from);
                stmt->setPosition(from);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case WHERE:{
      if (!hasError) {
      where = sqlWhere();
      }
      if (!hasError) {
stmt->setWhere(where);
                        stmt->setPosition(where);
      }
      break;
      }
    default:
      jj_la1[101] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLWhere        * AlinousLang::sqlWhere() {SQLWhere* stmt = new SQLWhere();
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
    if (!hasError) {
    t = jj_consume_token(WHERE);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    exp = sqlExpression();
    }
    if (!hasError) {
stmt->setExpression(exp);
                stmt->setPosition(exp);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


SQLFrom       * AlinousLang::sqlFrom() {SQLFrom* stmt = new SQLFrom();
        Token* t = nullptr;
        AbstractJoinPart* tableId = nullptr;
    if (!hasError) {
    t = jj_consume_token(FROM);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    tableId = tableList();
    }
    if (!hasError) {
stmt->setTable(tableId);
                stmt->setPosition(tableId);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


BeginStatement              * AlinousLang::beginStatement() {BeginStatement* stmt = new BeginStatement();
        Token* t = null;
    if (!hasError) {
    t = jj_consume_token(BEGIN);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


CommitStatement               * AlinousLang::commitStatement() {CommitStatement* stmt = new CommitStatement();
        Token* t = null;
    if (!hasError) {
    t = jj_consume_token(COMMIT);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


RollbackStatement                 * AlinousLang::rollbackStatement() {RollbackStatement* stmt = new RollbackStatement();
        Token* t = null;
    if (!hasError) {
    t = jj_consume_token(ROLLBACK);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(SEMI_COLON);
    }
    if (!hasError) {
stmt->setPosition(t);
    }
__ONERROR(stmt);
                return stmt;
assert(false);
}


AbstractSQLExpression
                     * AlinousLang::sqlExpression() {AbstractSQLExpression* exp = nullptr;
    if (!hasError) {
    if (!hasError) {
    exp = sqlOrExpression();
    }
    }
    if (!hasError) {

    }
return exp;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlOrExpression() {SQLOrExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlAndExpression();
    }
    if (!hasError) {
    while (!hasError) {
      if (jj_2_18(2)) {
        ;
      } else {
        goto end_label_36;
      }
      if (!hasError) {
      t = jj_consume_token(OR);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new SQLOrExpression();
                                exp->addOperand(left);
                                exp->setPosition(left);
                                left = exp;
                        }

                        exp->setPosition(t);
      }
      if (!hasError) {
      right = sqlAndExpression();
      }
      if (!hasError) {
exp->addOperand(right);
                        exp->setPosition(right);
      }
    }
    end_label_36: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlAndExpression() {SQLAndExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlNotExpression();
    }
    if (!hasError) {
    while (!hasError) {
      if (jj_2_19(2)) {
        ;
      } else {
        goto end_label_37;
      }
      if (!hasError) {
      t = jj_consume_token(SQLAND);
      }
      if (!hasError) {
if(exp == nullptr){
                                exp = new SQLAndExpression();
                                exp->addOperand(left);
                                exp->setPosition(left);
                                left = exp;
                        }

                        exp->setPosition(t);
      }
      if (!hasError) {
      right = sqlNotExpression();
      }
      if (!hasError) {
exp->addOperand(right);
                        exp->setPosition(right);
      }
    }
    end_label_37: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlNotExpression() {SQLNotExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SQL_NOT:{
      if (!hasError) {
      t = jj_consume_token(SQL_NOT);
      }
      if (!hasError) {
exp = new SQLNotExpression();
                        exp->setPosition(t);
                        left = exp;
      }
      break;
      }
    default:
      jj_la1[102] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    right = sqlLikeExpression();
    }
    if (!hasError) {
if(left == nullptr){
                        left = right;
                }
                else{
                        exp->setExpression(right);
                        exp->setPosition(right);
                }
    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlLikeExpression() {SQLLikeExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        SQLLiteral* right = nullptr;
    if (!hasError) {
    left = sqlIsNullExpression();
    }
    if (!hasError) {
    if (jj_2_20(2)) {
      if (!hasError) {
      t = jj_consume_token(LIKE);
      }
      if (!hasError) {
exp = new SQLLikeExpression();
                        exp->setLeft(left);

                        exp->setPosition(left);
                        exp->setPosition(t);
                        left = exp;
      }
      if (!hasError) {
      right = sqlLiteral();
      }
      if (!hasError) {
exp->setRight(right);
                        exp->setPosition(right);
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ESCAPE:{
        if (!hasError) {
        t = jj_consume_token(ESCAPE);
        }
        if (!hasError) {
exp->setPosition(t);
        }
        if (!hasError) {
        right = sqlLiteral();
        }
        if (!hasError) {
exp->setEscape(right);
                                exp->setPosition(right);
        }
        break;
        }
      default:
        jj_la1[103] = jj_gen;
        ;
      }
      }
    } else {
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlIsNullExpression() {SQLIsNullExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlBetweenExpression();
    }
    if (!hasError) {
    if (jj_2_21(2)) {
      if (!hasError) {
      t = jj_consume_token(IS);
      }
      if (!hasError) {
exp = new SQLIsNullExpression();
                        exp->setExpression(left);

                        exp->setPosition(left);
                        exp->setPosition(t);
                        left = exp;
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SQL_NOT:{
        if (!hasError) {
        t = jj_consume_token(SQL_NOT);
        }
        if (!hasError) {
exp->setNotNull(true);
                                exp->setPosition(t);
        }
        break;
        }
      default:
        jj_la1[104] = jj_gen;
        ;
      }
      }
      if (!hasError) {
      t = jj_consume_token(_NULL);
      }
      if (!hasError) {
exp->setPosition(t);
      }
    } else {
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlBetweenExpression() {SQLBetweenExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlInExpression();
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case BETWEEN:{
      if (!hasError) {
      t = jj_consume_token(BETWEEN);
      }
      if (!hasError) {
exp = new SQLBetweenExpression();
                        exp->setLeft(left);

                        exp->setPosition(left);
                        exp->setPosition(t);
                        left = exp;
      }
      if (!hasError) {
      right = sqlAdditiveExpression();
      }
      if (!hasError) {
exp->setStart(right);
                        exp->setPosition(right);
      }
      if (!hasError) {
      t = jj_consume_token(SQLAND);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      right = sqlAdditiveExpression();
      }
      if (!hasError) {
exp->setEnd(right);
                        exp->setPosition(right);
      }
      break;
      }
    default:
      jj_la1[105] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlInExpression() {SQLInExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        SQLExpressionList* list = nullptr;
    if (!hasError) {
    left = sqlRelationalExpression();
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IN:{
      if (!hasError) {
      t = jj_consume_token(IN);
      }
      if (!hasError) {
exp = new SQLInExpression();
                        exp->setLeft(left);

                        exp->setPosition(left);
                        exp->setPosition(t);
                        left = exp;
      }
      if (!hasError) {
      t = jj_consume_token(L_PARENTHESIS);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      list = sqlExpressionList();
      }
      if (!hasError) {
exp->setList(list);
      }
      if (!hasError) {
      t = jj_consume_token(R_PARENTHESIS);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[106] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlRelationalExpression() {SQLRelationalExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlEqualityExpression();
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case GT:
    case GEQ:
    case LT:
    case LEQ:{
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LT:{
        if (!hasError) {
        t = jj_consume_token(LT);
        }
        if (!hasError) {
exp = new SQLRelationalExpression();
                                exp->setLeft(left);
                                exp->setOp(SQLRelationalExpression::LT);
                                exp->setPosition(left);
                                exp->setPosition(t);

                                left = exp;
        }
        break;
        }
      case GT:{
        if (!hasError) {
        t = jj_consume_token(GT);
        }
        if (!hasError) {
exp = new SQLRelationalExpression();
                                exp->setLeft(left);
                                exp->setOp(SQLRelationalExpression::GT);
                                exp->setPosition(left);
                                exp->setPosition(t);

                                left = exp;
        }
        break;
        }
      case LEQ:{
        if (!hasError) {
        t = jj_consume_token(LEQ);
        }
        if (!hasError) {
exp = new SQLRelationalExpression();
                                exp->setLeft(left);
                                exp->setOp(SQLRelationalExpression::LT_EQ);
                                exp->setPosition(left);
                                exp->setPosition(t);

                                left = exp;
        }
        break;
        }
      case GEQ:{
        if (!hasError) {
        t = jj_consume_token(GEQ);
        }
        if (!hasError) {
exp = new SQLRelationalExpression();
                                exp->setLeft(left);
                                exp->setOp(SQLRelationalExpression::GT_EQ);
                                exp->setPosition(left);
                                exp->setPosition(t);

                                left = exp;
        }
        break;
        }
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = sqlEqualityExpression();
      }
      if (!hasError) {
exp->setRight(right);
                        exp->setPosition(right);
      }
      break;
      }
    default:
      jj_la1[108] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlEqualityExpression() {SQLEqualityExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlAdditiveExpression();
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case EQUALS:
    case CMP_NOTEQUALS:
    case 194:{
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQUALS:{
        if (!hasError) {
        t = jj_consume_token(EQUALS);
        }
        if (!hasError) {
exp = new SQLEqualityExpression();
                                exp->setLeft(left);
                                exp->setOp(SQLEqualityExpression::EQ);
                                exp->setPosition(left);
                                exp->setPosition(t);

                                left = exp;
        }
        break;
        }
      case 194:{
        if (!hasError) {
        t = jj_consume_token(194);
        }
        if (!hasError) {
exp = new SQLEqualityExpression();
                                exp->setLeft(left);
                                exp->setOp(SQLEqualityExpression::NOT_EQ);
                                exp->setPosition(left);
                                exp->setPosition(t);

                                left = exp;
        }
        break;
        }
      case CMP_NOTEQUALS:{
        if (!hasError) {
        t = jj_consume_token(CMP_NOTEQUALS);
        }
        if (!hasError) {
exp = new SQLEqualityExpression();
                                exp->setLeft(left);
                                exp->setOp(SQLEqualityExpression::NOT_EQ);
                                exp->setPosition(left);
                                exp->setPosition(t);

                                left = exp;
        }
        break;
        }
      default:
        jj_la1[109] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = sqlAdditiveExpression();
      }
      if (!hasError) {
exp->setRight(right);
                        exp->setPosition(right);
      }
      break;
      }
    default:
      jj_la1[110] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlAdditiveExpression() {SQLAdditiveExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlMultiplicativeExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:
      case MINUS:{
        ;
        break;
        }
      default:
        jj_la1[111] = jj_gen;
        goto end_label_38;
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        if (!hasError) {
        t = jj_consume_token(PLUS);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new SQLAdditiveExpression();
                                        exp->addOperand(left);
                                        exp->setPosition(left);
                                        left = exp;
                                }
                                exp->addOpe(SQLAdditiveExpression::ADD);
                                exp->setPosition(t);
        }
        break;
        }
      case MINUS:{
        if (!hasError) {
        t = jj_consume_token(MINUS);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new SQLAdditiveExpression();
                                        exp->addOperand(left);
                                        exp->setPosition(left);
                                        left = exp;
                                }
                                exp->addOpe(SQLAdditiveExpression::SUB);
                                exp->setPosition(t);
        }
        break;
        }
      default:
        jj_la1[112] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = sqlMultiplicativeExpression();
      }
      if (!hasError) {
exp->addOperand(right);
                        exp->setPosition(right);
      }
    }
    end_label_38: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlMultiplicativeExpression() {SqlMultiplicativeExpression* exp = nullptr;
        Token* t = nullptr;
        AbstractSQLExpression* left = nullptr;
        AbstractSQLExpression* right = nullptr;
    if (!hasError) {
    left = sqlPrimitiveExpression();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:
      case DIV:
      case MODULO:{
        ;
        break;
        }
      default:
        jj_la1[113] = jj_gen;
        goto end_label_39;
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASTERISK:{
        if (!hasError) {
        t = jj_consume_token(ASTERISK);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new SqlMultiplicativeExpression();
                                        exp->addOperand(left);
                                        exp->setPosition(left);
                                        left = exp;
                                }
                                exp->addOpe(SqlMultiplicativeExpression::MUL);
                                exp->setPosition(t);
        }
        break;
        }
      case DIV:{
        if (!hasError) {
        t = jj_consume_token(DIV);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new SqlMultiplicativeExpression();
                                        exp->addOperand(left);
                                        exp->setPosition(left);
                                        left = exp;
                                }
                                exp->addOpe(SqlMultiplicativeExpression::DIV);
                                exp->setPosition(t);
        }
        break;
        }
      case MODULO:{
        if (!hasError) {
        t = jj_consume_token(MODULO);
        }
        if (!hasError) {
if(exp == nullptr){
                                        exp = new SqlMultiplicativeExpression();
                                        exp->addOperand(left);
                                        exp->setPosition(left);
                                        left = exp;
                                }
                                exp->addOpe(SqlMultiplicativeExpression::MOD);
                                exp->setPosition(t);
        }
        break;
        }
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
      right = sqlPrimitiveExpression();
      }
      if (!hasError) {
exp->addOperand(right);
                        exp->setPosition(right);
      }
    }
    end_label_39: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractSQLExpression                     * AlinousLang::sqlPrimitiveExpression() {AbstractSQLExpression* exp = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case _NULL:{
      if (!hasError) {
      exp = sqlNullLiteral();
      }
      break;
      }
    case ASTERISK:{
      if (!hasError) {
      exp = sqlWildCard();
      }
      break;
      }
    case L_PARENTHESIS:{
      if (!hasError) {
      exp = sqlParenthesisExpression();
      }
      break;
      }
    case INTEGER_LITERAL:
    case CHARACTER_LITERAL:
    case SQL_STRING_LITERAL:{
      if (!hasError) {
      exp = sqlLiteral();
      }
      break;
      }
    case TRUE:
    case FALSE:{
      if (!hasError) {
      exp = sqlBooleanLiteral();
      }
      break;
      }
    default:
      jj_la1[115] = jj_gen;
      if (jj_2_22(2)) {
        if (!hasError) {
        exp = sqlFunctionCall();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case SUPER:
        case THIS:
        case INNER:
        case OUTER:
        case FULL:
        case JOIN:
        case CROSS:
        case VALUES:
        case GROUP:
        case BY:
        case HAVING:
        case ORDER:
        case ASC:
        case DESC:
        case LIMIT:
        case OFFSET:
        case ON:
        case AS:
        case DISTINCT:
        case SHARE:
        case NOWAIT:
        case OF:
        case IN:
        case BETWEEN:
        case CREATE:
        case DROP:
        case TABLE:
        case SQL_DEFAULT:
        case ADD:
        case RENAME:
        case COLUMN:
        case TO:
        case PRIMARY:
        case KEY:
        case UNIQUE:
        case CHECK:
        case RETURNS:
        case SETOF:
        case LANGUAGE:
        case REPLACE:
        case INDEX:
        case USING:
        case IDENTIFIER:{
          if (!hasError) {
          exp = sqlColumnIdentifier();
          }
          break;
          }
        case DOLLAR:{
          if (!hasError) {
          exp = sqlPlaceHolder();
          }
          break;
          }
        default:
          jj_la1[116] = jj_gen;
          jj_consume_token(-1);
          errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
        }
      }
    }
    }
    if (!hasError) {

    }
return exp;
assert(false);
}


SQLNullLiteral              * AlinousLang::sqlNullLiteral() {SQLNullLiteral* exp = new SQLNullLiteral();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(_NULL);
    }
    if (!hasError) {
exp->setPosition(t);
    }
__ONERROR(exp);
                return exp;
assert(false);
}


SQLWildCard           * AlinousLang::sqlWildCard() {SQLWildCard* exp = new SQLWildCard();
        Token* t = nullptr;
    if (!hasError) {
    t = jj_consume_token(ASTERISK);
    }
    if (!hasError) {
exp->setPosition(t);
    }
__ONERROR(exp);
                return exp;
assert(false);
}


SQLFunctionCall               * AlinousLang::sqlFunctionCall() {SQLFunctionCall* exp = new SQLFunctionCall();
        Token* t = nullptr;
        VariableIdentifier* name = nullptr;
    if (!hasError) {
    name = variableIdentifier();
    }
    if (!hasError) {
exp->setName(name);
                exp->setPosition(name);
    }
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
    if (!hasError) {
    sqlFunctionCallArguments(exp);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
__ONERROR(exp);
                return exp;
assert(false);
}


void AlinousLang::sqlFunctionCallArguments(SQLFunctionCall* exp) {AbstractSQLExpression* ex = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:
    case CHARACTER_LITERAL:
    case SQL_STRING_LITERAL:
    case ASTERISK:
    case L_PARENTHESIS:
    case DOLLAR:
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SUPER:
    case THIS:
    case TRUE:
    case FALSE:
    case INNER:
    case OUTER:
    case FULL:
    case JOIN:
    case CROSS:
    case VALUES:
    case GROUP:
    case BY:
    case HAVING:
    case ORDER:
    case ASC:
    case DESC:
    case LIMIT:
    case OFFSET:
    case ON:
    case SQL_NOT:
    case AS:
    case DISTINCT:
    case SHARE:
    case NOWAIT:
    case OF:
    case IN:
    case BETWEEN:
    case CREATE:
    case DROP:
    case TABLE:
    case SQL_DEFAULT:
    case ADD:
    case RENAME:
    case COLUMN:
    case TO:
    case PRIMARY:
    case KEY:
    case UNIQUE:
    case CHECK:
    case RETURNS:
    case SETOF:
    case LANGUAGE:
    case REPLACE:
    case INDEX:
    case USING:
    case _NULL:
    case IDENTIFIER:{
      if (!hasError) {
      ex = sqlDistinctArgument();
      }
      if (!hasError) {
exp->addArgument(ex);
                        exp->setPosition(ex);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[117] = jj_gen;
          goto end_label_40;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
exp->setPosition(t);
        }
        if (!hasError) {
        ex = sqlExpression();
        }
        if (!hasError) {
exp->addArgument(ex);
                                exp->setPosition(ex);
        }
      }
      end_label_40: ;
      }
      break;
      }
    default:
      jj_la1[118] = jj_gen;
      ;
    }
    }
}


AbstractSQLExpression                     * AlinousLang::sqlDistinctArgument() {SQLDistinctArgument* dist = nullptr;
        AbstractSQLExpression* ex = nullptr;
        Token* t = nullptr;
    if (!hasError) {
    if (jj_2_23(2)) {
      if (!hasError) {
      t = jj_consume_token(DISTINCT);
      }
      if (!hasError) {
dist = new SQLDistinctArgument();
                        dist->setPosition(t);
      }
    } else {
      ;
    }
    }
    if (!hasError) {
    ex = sqlExpression();
    }
    if (!hasError) {
if(t != nullptr){
                        dist->setPosition(ex);
                        dist->setExpression(ex);
                        ex = dist;
                }
    }
return ex;
assert(false);
}


SQLPlaceHolder              * AlinousLang::sqlPlaceHolder() {SQLPlaceHolder* exp = new SQLPlaceHolder();
        Token* t = nullptr;
        AbstractExpression* ex = nullptr;
    if (!hasError) {
    t = jj_consume_token(DOLLAR);
    }
    if (!hasError) {
exp->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(L_BRACE);
    }
    if (!hasError) {
exp->setPosition(t);
    }
    if (!hasError) {
    ex = expression();
    }
    if (!hasError) {
exp->setExpression(ex);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case COMMA:{
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      ex = expression();
      }
      if (!hasError) {
exp->setAvailable(ex);
      }
      break;
      }
    default:
      jj_la1[119] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(R_BRACE);
    }
    if (!hasError) {
exp->setPosition(t);
    }
__ONERROR(exp);
                return exp;
assert(false);
}


SQLParenthesisExpression                        * AlinousLang::sqlParenthesisExpression() {SQLParenthesisExpression* exp = new SQLParenthesisExpression();
        Token* t = nullptr;
        AbstractSQLExpression* ex = nullptr;
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
    if (!hasError) {
    ex = sqlExpression();
    }
    if (!hasError) {
exp->setExpression(ex);
                exp->setPosition(ex);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
exp->setPosition(t);
    }
__ONERROR(exp);
                return exp;
assert(false);
}


SQLLiteral          * AlinousLang::sqlLiteral() {SQLLiteral* exp = new SQLLiteral();
        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:{
      if (!hasError) {
      t = jj_consume_token(INTEGER_LITERAL);
      }
      if (!hasError) {
exp->setValue(_STR(t), SQLLiteral::TYPE_NUMBER);
                        exp->setPosition(t);
      }
      break;
      }
    case SQL_STRING_LITERAL:{
      if (!hasError) {
      t = jj_consume_token(SQL_STRING_LITERAL);
      }
      if (!hasError) {
exp->setValue(_STR(t), SQLLiteral::TYPE_STRING);
                        exp->setPosition(t);
      }
      break;
      }
    case CHARACTER_LITERAL:{
      if (!hasError) {
      t = jj_consume_token(CHARACTER_LITERAL);
      }
      if (!hasError) {
exp->setValue(_STR(t), SQLLiteral::TYPE_STRING);
                        exp->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[120] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
__ONERROR(exp);
                return exp;
assert(false);
}


SQLBooleanLiteral                 * AlinousLang::sqlBooleanLiteral() {SQLBooleanLiteral* exp = new SQLBooleanLiteral();
        Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case TRUE:{
      if (!hasError) {
      t = jj_consume_token(TRUE);
      }
      if (!hasError) {
exp->setValue(true);
                        exp->setPosition(t);
      }
      break;
      }
    case FALSE:{
      if (!hasError) {
      t = jj_consume_token(FALSE);
      }
      if (!hasError) {
exp->setValue(false);
                        exp->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[121] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
__ONERROR(exp);
                return exp;
assert(false);
}


SQLColumnIdentifier                   * AlinousLang::sqlColumnIdentifier() {SQLColumnIdentifier* exp = new SQLColumnIdentifier();
        Token* t = nullptr;
        Token* t1 = nullptr;
        Token* t2 = nullptr;
        Token* t3 = nullptr;
    if (!hasError) {
    t1 = sqlIdentifierName();
    }
    if (!hasError) {
exp->setPosition(t1);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOT:{
      if (!hasError) {
      t = jj_consume_token(DOT);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      t2 = sqlIdentifierName();
      }
      if (!hasError) {
exp->setPosition(t2);
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case DOT:{
        if (!hasError) {
        t = jj_consume_token(DOT);
        }
        if (!hasError) {
exp->setPosition(t);
        }
        if (!hasError) {
        t3 = sqlIdentifierName();
        }
        if (!hasError) {
exp->setPosition(t3);
        }
        break;
        }
      default:
        jj_la1[122] = jj_gen;
        ;
      }
      }
      break;
      }
    default:
      jj_la1[123] = jj_gen;
      ;
    }
    }
    if (!hasError) {
if(t3 != nullptr){
                        exp->setSchema(_STR(t1));
                        exp->setTableName(_STR(t2));
                        exp->setColumnName(_STR(t3));
                }
                else if(t2 != nullptr){
                        exp->setTableName(_STR(t1));
                        exp->setColumnName(_STR(t2));
                }
                else{
                        exp->setColumnName(_STR(t1));
                }
    }
__ONERROR(exp);
                return exp;
assert(false);
}


Token     * AlinousLang::sqlIdentifierName() {Token* t = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFIER:{
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      break;
      }
    case THIS:{
      if (!hasError) {
      t = jj_consume_token(THIS);
      }
      break;
      }
    case SUPER:{
      if (!hasError) {
      t = jj_consume_token(SUPER);
      }
      break;
      }
    case INNER:{
      if (!hasError) {
      t = jj_consume_token(INNER);
      }
      break;
      }
    case OUTER:{
      if (!hasError) {
      t = jj_consume_token(OUTER);
      }
      break;
      }
    case FULL:{
      if (!hasError) {
      t = jj_consume_token(FULL);
      }
      break;
      }
    case JOIN:{
      if (!hasError) {
      t = jj_consume_token(JOIN);
      }
      break;
      }
    case VALUES:{
      if (!hasError) {
      t = jj_consume_token(VALUES);
      }
      break;
      }
    case CROSS:{
      if (!hasError) {
      t = jj_consume_token(CROSS);
      }
      break;
      }
    case GROUP:{
      if (!hasError) {
      t = jj_consume_token(GROUP);
      }
      break;
      }
    case BY:{
      if (!hasError) {
      t = jj_consume_token(BY);
      }
      break;
      }
    case HAVING:{
      if (!hasError) {
      t = jj_consume_token(HAVING);
      }
      break;
      }
    case ORDER:{
      if (!hasError) {
      t = jj_consume_token(ORDER);
      }
      break;
      }
    case ASC:{
      if (!hasError) {
      t = jj_consume_token(ASC);
      }
      break;
      }
    case DESC:{
      if (!hasError) {
      t = jj_consume_token(DESC);
      }
      break;
      }
    case LIMIT:{
      if (!hasError) {
      t = jj_consume_token(LIMIT);
      }
      break;
      }
    case OFFSET:{
      if (!hasError) {
      t = jj_consume_token(OFFSET);
      }
      break;
      }
    case ON:{
      if (!hasError) {
      t = jj_consume_token(ON);
      }
      break;
      }
    case AS:{
      if (!hasError) {
      t = jj_consume_token(AS);
      }
      break;
      }
    case DISTINCT:{
      if (!hasError) {
      t = jj_consume_token(DISTINCT);
      }
      break;
      }
    case SHARE:{
      if (!hasError) {
      t = jj_consume_token(SHARE);
      }
      break;
      }
    case NOWAIT:{
      if (!hasError) {
      t = jj_consume_token(NOWAIT);
      }
      break;
      }
    case OF:{
      if (!hasError) {
      t = jj_consume_token(OF);
      }
      break;
      }
    case IN:{
      if (!hasError) {
      t = jj_consume_token(IN);
      }
      break;
      }
    case BETWEEN:{
      if (!hasError) {
      t = jj_consume_token(BETWEEN);
      }
      break;
      }
    case CREATE:{
      if (!hasError) {
      t = jj_consume_token(CREATE);
      }
      break;
      }
    case DROP:{
      if (!hasError) {
      t = jj_consume_token(DROP);
      }
      break;
      }
    case TABLE:{
      if (!hasError) {
      t = jj_consume_token(TABLE);
      }
      break;
      }
    case SQL_DEFAULT:{
      if (!hasError) {
      t = jj_consume_token(SQL_DEFAULT);
      }
      break;
      }
    case ADD:{
      if (!hasError) {
      t = jj_consume_token(ADD);
      }
      break;
      }
    case RENAME:{
      if (!hasError) {
      t = jj_consume_token(RENAME);
      }
      break;
      }
    case COLUMN:{
      if (!hasError) {
      t = jj_consume_token(COLUMN);
      }
      break;
      }
    case TO:{
      if (!hasError) {
      t = jj_consume_token(TO);
      }
      break;
      }
    case PRIMARY:{
      if (!hasError) {
      t = jj_consume_token(PRIMARY);
      }
      break;
      }
    case KEY:{
      if (!hasError) {
      t = jj_consume_token(KEY);
      }
      break;
      }
    case UNIQUE:{
      if (!hasError) {
      t = jj_consume_token(UNIQUE);
      }
      break;
      }
    case CHECK:{
      if (!hasError) {
      t = jj_consume_token(CHECK);
      }
      break;
      }
    case RETURNS:{
      if (!hasError) {
      t = jj_consume_token(RETURNS);
      }
      break;
      }
    case SETOF:{
      if (!hasError) {
      t = jj_consume_token(SETOF);
      }
      break;
      }
    case LANGUAGE:{
      if (!hasError) {
      t = jj_consume_token(LANGUAGE);
      }
      break;
      }
    case REPLACE:{
      if (!hasError) {
      t = jj_consume_token(REPLACE);
      }
      break;
      }
    case INDEX:{
      if (!hasError) {
      t = jj_consume_token(INDEX);
      }
      break;
      }
    case USING:{
      if (!hasError) {
      t = jj_consume_token(USING);
      }
      break;
      }
    case PUBLIC:{
      if (!hasError) {
      t = jj_consume_token(PUBLIC);
      }
      break;
      }
    case PROTECTED:{
      if (!hasError) {
      t = jj_consume_token(PROTECTED);
      }
      break;
      }
    case PRIVATE:{
      if (!hasError) {
      t = jj_consume_token(PRIVATE);
      }
      break;
      }
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
return t;
assert(false);
}


SQLExpressionList
                 * AlinousLang::sqlExpressionList() {SQLExpressionList* exp = new SQLExpressionList();
        Token* t = nullptr;
        AbstractSQLExpression* ex = nullptr;
    if (!hasError) {
    ex = sqlExpression();
    }
    if (!hasError) {
exp->addExpression(ex);
                exp->setPosition(ex);
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[125] = jj_gen;
        goto end_label_41;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      ex = sqlExpression();
      }
      if (!hasError) {
exp->addExpression(ex);
                        exp->setPosition(ex);
      }
    }
    end_label_41: ;
    }
    if (!hasError) {

    }
__ONERROR(exp);
                return exp;
assert(false);
}


AbstractJoinPart
                * AlinousLang::tableList() {AbstractJoinPart* left = nullptr;
        TableList* tablelist = nullptr;
        Token* t = nullptr;
        TableIdentifier* table = nullptr;
    if (!hasError) {
    left = join();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        ;
        break;
        }
      default:
        jj_la1[126] = jj_gen;
        goto end_label_42;
      }
      if (!hasError) {
      t = jj_consume_token(COMMA);
      }
      if (!hasError) {
if(tablelist == nullptr){
                                tablelist =  new TableList();
                                tablelist->addTable(left);
                                tablelist->setPosition(left);

                                left = tablelist;
                        }

                        tablelist->setPosition(t);
      }
      if (!hasError) {
      table = tableIdentifier();
      }
      if (!hasError) {
tablelist->addTable(table);
                        tablelist->setPosition(table);
      }
    }
    end_label_42: ;
    }
    if (!hasError) {

    }
__ONERROR(left);
                return left;
assert(false);
}


AbstractJoinPart                * AlinousLang::join() {AbstractJoinPart* left = nullptr;
        SQLJoinPart* right = nullptr;
        SQLJoin* joinBody = nullptr;
    if (!hasError) {
    left = joinTarget();
    }
    if (!hasError) {
    while (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT:
      case RIGHT:
      case INNER:
      case CROSS:{
        ;
        break;
        }
      default:
        jj_la1[127] = jj_gen;
        goto end_label_43;
      }
      if (!hasError) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEFT:{
        if (!hasError) {
        right = leftJoin();
        }
        break;
        }
      case RIGHT:{
        if (!hasError) {
        right = rightJoin();
        }
        break;
        }
      case INNER:{
        if (!hasError) {
        right = innerJoin();
        }
        break;
        }
      case CROSS:{
        if (!hasError) {
        right = crossJoin();
        }
        break;
        }
      default:
        jj_la1[128] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
      }
      if (!hasError) {
if(joinBody == nullptr){
                                joinBody = new SQLJoin();
                                joinBody->setPosition(left);
                                joinBody->setFirst(left);

                                left = joinBody;
                        }

                        joinBody->addJoinPart(right);
      }
    }
    end_label_43: ;
    }
__ONERROR(left);
                return left;
assert(false);
}


SQLJoinPart           * AlinousLang::innerJoin() {SQLJoinPart* join = new SQLJoinPart();
        join->setJoinType(SQLJoinPart::INNER_JOIN);
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
        AbstractJoinPart* table = nullptr;
    if (!hasError) {
    t = jj_consume_token(INNER);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(JOIN);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    table = joinTarget();
    }
    if (!hasError) {
join->setTable(table);
                join->setPosition(table);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ON:{
      if (!hasError) {
      t = jj_consume_token(ON);
      }
      if (!hasError) {
join->setPosition(t);
      }
      if (!hasError) {
      exp = sqlExpression();
      }
      if (!hasError) {
join->setExpression(exp);
                        join->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[129] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(join);
                return join;
assert(false);
}


SQLJoinPart           * AlinousLang::leftJoin() {SQLJoinPart* join = new SQLJoinPart();
        join->setJoinType(SQLJoinPart::LEFT_OUTER_JOIN);
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
        AbstractJoinPart* table = nullptr;
    if (!hasError) {
    t = jj_consume_token(LEFT);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OUTER:{
      if (!hasError) {
      t = jj_consume_token(OUTER);
      }
      if (!hasError) {
join->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[130] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(JOIN);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    table = joinTarget();
    }
    if (!hasError) {
join->setTable(table);
                join->setPosition(table);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ON:{
      if (!hasError) {
      t = jj_consume_token(ON);
      }
      if (!hasError) {
join->setPosition(t);
      }
      if (!hasError) {
      exp = sqlExpression();
      }
      if (!hasError) {
join->setExpression(exp);
                        join->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[131] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(join);
                return join;
assert(false);
}


SQLJoinPart           * AlinousLang::rightJoin() {SQLJoinPart* join = new SQLJoinPart();
        join->setJoinType(SQLJoinPart::RIGHT_OUTER_JOIN);
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
        AbstractJoinPart* table = nullptr;
    if (!hasError) {
    t = jj_consume_token(RIGHT);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OUTER:{
      if (!hasError) {
      t = jj_consume_token(OUTER);
      }
      if (!hasError) {
join->setPosition(t);
      }
      break;
      }
    default:
      jj_la1[132] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(JOIN);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    table = joinTarget();
    }
    if (!hasError) {
join->setTable(table);
                join->setPosition(table);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ON:{
      if (!hasError) {
      t = jj_consume_token(ON);
      }
      if (!hasError) {
join->setPosition(t);
      }
      if (!hasError) {
      exp = sqlExpression();
      }
      if (!hasError) {
join->setExpression(exp);
                        join->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[133] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(join);
                return join;
assert(false);
}


SQLJoinPart           * AlinousLang::crossJoin() {SQLJoinPart* join = new SQLJoinPart();
        join->setJoinType(SQLJoinPart::CROSS_JOIN);
        Token* t = nullptr;
        AbstractSQLExpression* exp = nullptr;
        AbstractJoinPart* table = nullptr;
    if (!hasError) {
    t = jj_consume_token(CROSS);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    t = jj_consume_token(JOIN);
    }
    if (!hasError) {
join->setPosition(t);
    }
    if (!hasError) {
    table = joinTarget();
    }
    if (!hasError) {
join->setTable(table);
                join->setPosition(table);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ON:{
      if (!hasError) {
      t = jj_consume_token(ON);
      }
      if (!hasError) {
join->setPosition(t);
      }
      if (!hasError) {
      exp = sqlExpression();
      }
      if (!hasError) {
join->setExpression(exp);
                        join->setPosition(exp);
      }
      break;
      }
    default:
      jj_la1[134] = jj_gen;
      ;
    }
    }
    if (!hasError) {

    }
__ONERROR(join);
                return join;
assert(false);
}


AbstractJoinPart                * AlinousLang::joinTarget() {AbstractJoinPart* target = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PRIVATE:
    case PROTECTED:
    case PUBLIC:
    case SUPER:
    case THIS:
    case INNER:
    case OUTER:
    case FULL:
    case JOIN:
    case CROSS:
    case VALUES:
    case GROUP:
    case BY:
    case HAVING:
    case ORDER:
    case ASC:
    case DESC:
    case LIMIT:
    case OFFSET:
    case ON:
    case AS:
    case DISTINCT:
    case SHARE:
    case NOWAIT:
    case OF:
    case IN:
    case BETWEEN:
    case CREATE:
    case DROP:
    case TABLE:
    case SQL_DEFAULT:
    case ADD:
    case RENAME:
    case COLUMN:
    case TO:
    case PRIMARY:
    case KEY:
    case UNIQUE:
    case CHECK:
    case RETURNS:
    case SETOF:
    case LANGUAGE:
    case REPLACE:
    case INDEX:
    case USING:
    case IDENTIFIER:{
      if (!hasError) {
      target = tableIdentifier();
      }
      break;
      }
    case L_PARENTHESIS:{
      if (!hasError) {
      target = parenthesisJoinPart();
      }
      break;
      }
    default:
      jj_la1[135] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {

    }
return target;
assert(false);
}


ParenthesisJoinPart                   * AlinousLang::parenthesisJoinPart() {ParenthesisJoinPart* part = new ParenthesisJoinPart();
        Token* t = nullptr;
        AbstractJoinPart* target = nullptr;
    if (!hasError) {
    t = jj_consume_token(L_PARENTHESIS);
    }
    if (!hasError) {
part->setPosition(t);
    }
    if (!hasError) {
    target = join();
    }
    if (!hasError) {
part->setPart(target);
                part->setPosition(target);
    }
    if (!hasError) {
    t = jj_consume_token(R_PARENTHESIS);
    }
    if (!hasError) {
part->setPosition(t);
    }
__ONERROR(part);
                return part;
assert(false);
}


TableIdentifier               * AlinousLang::tableIdentifier() {TableIdentifier* exp = new TableIdentifier();
        Token* t = nullptr;
        Token* t1 = nullptr;
        Token* t2 = nullptr;
    if (!hasError) {
    t1 = sqlIdentifierName();
    }
    if (!hasError) {
exp->setPosition(t1);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DOT:{
      if (!hasError) {
      t = jj_consume_token(DOT);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      t2 = sqlIdentifierName();
      }
      if (!hasError) {
exp->setPosition(t2);
      }
      break;
      }
    default:
      jj_la1[136] = jj_gen;
      ;
    }
    }
    if (!hasError) {
if(t2 != nullptr){
                        exp->setSchema(_STR(t1));
                        exp->setTableName(_STR(t2));
                }
                else{
                        exp->setTableName(_STR(t1));
                }
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case AS:{
      if (!hasError) {
      t = jj_consume_token(AS);
      }
      if (!hasError) {
exp->setPosition(t);
      }
      if (!hasError) {
      t = sqlIdentifierName();
      }
      if (!hasError) {
exp->setPosition(t);
                        exp->setAlias(_STR(t));
      }
      break;
      }
    default:
      jj_la1[137] = jj_gen;
      ;
    }
    }
__ONERROR(exp);
                return exp;
assert(false);
}


AbstractJsonExpression
                      * AlinousLang::jsonElement() {AbstractJsonExpression* jsonExp = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case L_BRACE:{
      if (!hasError) {
      jsonExp = jsonInitializerExpression();
      }
      break;
      }
    case L_BRACKET:{
      if (!hasError) {
      jsonExp = jsonArrayExpression();
      }
      break;
      }
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:
    case IDENTIFIER:{
      if (!hasError) {
      jsonExp = jsonKeyValuePair();
      }
      break;
      }
    default:
      jj_la1[138] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
__ONERROR(jsonExp);
                return jsonExp;
assert(false);
}


JsonInitializerExpression                         * AlinousLang::jsonInitializerExpression() {JsonInitializerExpression* jsonExp = new JsonInitializerExpression();
        Token* t = nullptr;
        JsonKeyValuePairExpression* element = nullptr;
    if (!hasError) {
    t = jj_consume_token(L_BRACE);
    }
    if (!hasError) {
jsonExp->setPosition(t);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:
    case IDENTIFIER:{
      if (!hasError) {
      element = jsonKeyValuePair();
      }
      if (!hasError) {
jsonExp->setPosition(element);
                        jsonExp->addElement(element);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[139] = jj_gen;
          goto end_label_44;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
jsonExp->setPosition(t);
        }
        if (!hasError) {
        element = jsonKeyValuePair();
        }
        if (!hasError) {
jsonExp->setPosition(element);
                                jsonExp->addElement(element);
        }
      }
      end_label_44: ;
      }
      break;
      }
    default:
      jj_la1[140] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(R_BRACE);
    }
    if (!hasError) {
jsonExp->setPosition(t);
    }
__ONERROR(jsonExp);
                return jsonExp;
assert(false);
}


JsonArrayExpression                   * AlinousLang::jsonArrayExpression() {JsonArrayExpression* jsonExp = new JsonArrayExpression();
        AbstractJsonExpression* element = nullptr;
        Token* t = nullptr;

        AbstractExpression* exp = nullptr;
    if (!hasError) {
    t = jj_consume_token(L_BRACKET);
    }
    if (!hasError) {
jsonExp->setPosition(t);
    }
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INTEGER_LITERAL:
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:
    case PLUSPLUS:
    case MINUSMINUS:
    case MINUS:
    case L_PARENTHESIS:
    case L_BRACKET:
    case L_BRACE:
    case NOT:
    case NEW:
    case SUPER:
    case THIS:
    case TRUE:
    case FALSE:
    case INNER:
    case OUTER:
    case FULL:
    case JOIN:
    case CROSS:
    case VALUES:
    case GROUP:
    case BY:
    case HAVING:
    case ORDER:
    case ASC:
    case DESC:
    case LIMIT:
    case OFFSET:
    case ON:
    case AS:
    case DISTINCT:
    case SHARE:
    case NOWAIT:
    case OF:
    case IN:
    case BETWEEN:
    case CREATE:
    case DROP:
    case TABLE:
    case SQL_DEFAULT:
    case ADD:
    case RENAME:
    case COLUMN:
    case TO:
    case PRIMARY:
    case KEY:
    case UNIQUE:
    case CHECK:
    case RETURNS:
    case SETOF:
    case LANGUAGE:
    case REPLACE:
    case INDEX:
    case USING:
    case _NULL:
    case IDENTIFIER:
    case 193:{
      if (!hasError) {
      exp = expression();
      }
      if (!hasError) {
jsonExp->setPosition(exp);
                        jsonExp->addElement(exp);
      }
      if (!hasError) {
      while (!hasError) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[141] = jj_gen;
          goto end_label_45;
        }
        if (!hasError) {
        t = jj_consume_token(COMMA);
        }
        if (!hasError) {
jsonExp->setPosition(t);
        }
        if (!hasError) {
        exp = expression();
        }
        if (!hasError) {
jsonExp->setPosition(exp);
                                jsonExp->addElement(exp);
        }
      }
      end_label_45: ;
      }
      break;
      }
    default:
      jj_la1[142] = jj_gen;
      ;
    }
    }
    if (!hasError) {
    t = jj_consume_token(R_BRACKET);
    }
    if (!hasError) {
jsonExp->setPosition(t);
    }
__ONERROR(jsonExp);
                return jsonExp;
assert(false);
}


JsonKeyValuePairExpression                          * AlinousLang::jsonKeyValuePair() {JsonKeyValuePairExpression* pair = new JsonKeyValuePairExpression();
        Token* t = nullptr;
        AbstractExpression* exp = nullptr;
        LiteralExpression* lit = nullptr;
        AbstractJsonExpression* jsonExp = nullptr;
    if (!hasError) {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_LITERAL:
    case SQL_STRING_LITERAL:{
      if (!hasError) {
      lit = literalExpression();
      }
      if (!hasError) {
pair->setPosition(lit);
                        pair->setName(lit);
      }
      break;
      }
    case IDENTIFIER:{
      if (!hasError) {
      t = jj_consume_token(IDENTIFIER);
      }
      if (!hasError) {
pair->setPosition(t);
                        pair->setName(_STR(t));
      }
      break;
      }
    default:
      jj_la1[143] = jj_gen;
      jj_consume_token(-1);
      errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
    }
    }
    if (!hasError) {
    t = jj_consume_token(COLON);
    }
    if (!hasError) {
pair->setPosition(t);
    }
    if (!hasError) {
    if (jj_2_24(2)) {
      if (!hasError) {
      exp = expression();
      }
      if (!hasError) {
pair->setPosition(exp);
                        pair->setValue(exp);
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STRING_LITERAL:
      case SQL_STRING_LITERAL:
      case L_BRACKET:
      case L_BRACE:
      case IDENTIFIER:{
        if (!hasError) {
        jsonExp = jsonElement();
        }
        if (!hasError) {
pair->setPosition(jsonExp);
                        pair->setValue(jsonExp);
        }
        break;
        }
      default:
        jj_la1[144] = jj_gen;
        jj_consume_token(-1);
        errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
      }
    }
    }
__ONERROR(pair);
                return pair;
assert(false);
}


  AlinousLang::AlinousLang(TokenManager *tokenManager){
    head = nullptr;
    ReInit(tokenManager);
}
AlinousLang::~AlinousLang()
{
  clear();
}

void AlinousLang::ReInit(TokenManager* tokenManager){
    clear();
    errorHandler = new ErrorHandler();
    hasError = false;
    token_source = tokenManager;
    head = token = new Token();
    token->kind = 0;
    token->next = nullptr;
    jj_lookingAhead = false;
    jj_rescan = false;
    jj_done = false;
    jj_scanpos = jj_lastpos = nullptr;
    jj_gc = 0;
    jj_kind = -1;
    indent = 0;
    trace = false;
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 145; i++) jj_la1[i] = -1;
  }


void AlinousLang::clear(){
  //Since token manager was generate from outside,
  //parser should not take care of deleting
  //if (token_source) delete token_source;
  if (head) {
    Token *next, *t = head;
    while (t) {
      next = t->next;
      delete t;
      t = next;
    }
  }
  if (errorHandler) {
    delete errorHandler, errorHandler = nullptr;
  }
}


Token * AlinousLang::jj_consume_token(int kind)  {
    Token *oldToken;
    if ((oldToken = token)->next != nullptr) token = token->next;
    else token = token->next = token_source->getNextToken();
    jj_ntk = -1;
    if (token->kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < 24; i++) {
          JJCalls *c = &jj_2_rtns[i];
          while (c != nullptr) {
            if (c->gen < jj_gen) c->first = nullptr;
            c = c->next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    JJString image = kind >= 0 ? tokenImage[kind] : tokenImage[0];
    errorHandler->handleUnexpectedToken(kind, image.substr(1, image.size() - 2), getToken(1), this);
    hasError = true;
    return token;
  }


bool  AlinousLang::jj_scan_token(int kind){
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos->next == nullptr) {
        jj_lastpos = jj_scanpos = jj_scanpos->next = token_source->getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos->next;
      }
    } else {
      jj_scanpos = jj_scanpos->next;
    }
    if (jj_rescan) {
      int i = 0; Token *tok = token;
      while (tok != nullptr && tok != jj_scanpos) { i++; tok = tok->next; }
      if (tok != nullptr) jj_add_error_token(kind, i);
    }
    if (jj_scanpos->kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) { return jj_done = true; }
    return false;
  }


/** Get the next Token. */

Token * AlinousLang::getNextToken(){
    if (token->next != nullptr) token = token->next;
    else token = token->next = token_source->getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */

Token * AlinousLang::getToken(int index){
    Token *t = token;
    for (int i = 0; i < index; i++) {
      if (t->next != nullptr) t = t->next;
      else t = t->next = token_source->getNextToken();
    }
    return t;
  }


int AlinousLang::jj_ntk_f(){
    if ((jj_nt=token->next) == nullptr)
      return (jj_ntk = (token->next=token_source->getNextToken())->kind);
    else
      return (jj_ntk = jj_nt->kind);
  }


  void AlinousLang::jj_add_error_token(int kind, int pos)  {
  }


 void  AlinousLang::parseError()   {
      fprintf(stderr, "Parse error at: %d:%d, after token: %s encountered: %s\n", token->beginLine, token->beginColumn, addUnicodeEscapes(token->image).c_str(), addUnicodeEscapes(getToken(1)->image).c_str());
   }


  bool AlinousLang::trace_enabled()  {
    return trace;
  }


  void AlinousLang::enable_tracing()  {
  }

  void AlinousLang::disable_tracing()  {
  }


  void AlinousLang::jj_rescan_token(){
    jj_rescan = true;
    for (int i = 0; i < 24; i++) {
      JJCalls *p = &jj_2_rtns[i];
      do {
        if (p->gen > jj_gen) {
          jj_la = p->arg; jj_lastpos = jj_scanpos = p->first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
          }
        }
        p = p->next;
      } while (p != nullptr);
    }
    jj_rescan = false;
  }


  void AlinousLang::jj_save(int index, int xla){
    JJCalls *p = &jj_2_rtns[index];
    while (p->gen > jj_gen) {
      if (p->next == nullptr) { p = p->next = new JJCalls(); break; }
      p = p->next;
    }
    p->gen = jj_gen + xla - jj_la; p->first = token; p->arg = xla;
  }


}
